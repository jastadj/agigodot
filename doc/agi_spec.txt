1.1 Introduction
Retrived from the Internet Archive
 
Last updated: 27 January 1998

This is a collection of all the information currently known about the structure and operation of Sierra's AGI interpreter.

AGI (Adventure Game Interpreter) was the first major interpreter used by Sierra. With the release of King's Quest 1 in the early 80's, it introduced the gaming world to the concept of a 3D graphical adventure game, where the player could move a character around the screen, behind, in front of and over objects. Other commands could be typed in, just like a text adventure. This concept, in various forms, has been used many many times since, by Sierra and other companies such as Lucasarts. It has proved very successful and continues to be used today in games such as Larry 7.

If you have any questions about the individual sections in this document, email the author of that section.

If you have documented an aspect of the interpreter, or have updated your documentation which is already included this document, please send it to me (Peter Kelly, ptrkelly@ozemail.com.au) so that I can add it. Please send it in HTML format if you can.

A note about diagrams:

When all the documentation was converted from ASCII text to HTML, there was the question of whether or not to do the diagrams as images, or just leave them as text. Although the documents looked better with images, we decided on text for two reasons - mainly because it was easier to save the whole page to disk (although there are programs around which will allow you to save images as well, but then you still need to use a web browser), but also so that they can be read in lynx (the text-based web browser).

Where can I get this document?

The latest version should always be available from http://www.ozemail.com.au/~ptrkelly/agi/specs/
A zipped copy can also be downloaded: agispecs.zip

1.2 What's New
Retrived from the Internet Archive
 
11 July 1998
Date corrected in section 2.5
Added a note on the main page explaining what AGI specs is for. Hopefully this will reduce the confusion that some people have been having when using this to learn the logic programming language.
3 March 1998
Updated section 2.5 with some more info about game IDs and interpreter encryption.
Corrected put and put.v commands in section 4.3 (the second argument of put and the first argument of put.v are supposed to be a vars).
27 January 1998
Removed sections 4.2 (logic structure), 3.4 (dir/vol file format), 6.2 (view format), 8.2 (OBJECT format) and 8.3 (WORDS.TOK format). These were sections from the AGDS documentation which contained basically the same information as other more recent documentation in AGI specs. Section numbers above those removed have been moved down.
Added sections 4.2 (LOGIC syntax) and 4.3 (command list & argument types)
Replaced section 2.2 and section 5.2 with a better translation
Added more info about the AGDS package in section 9.2
Updated section 9.1 (websites and people)
Corrected the title of section 3.3 from "Version 2 resource storage" to "Version 3 resource storage".
Updated the URL for the windows help version of AGI specs in section 1.1
Fixed up a small formatting error in section 2.8 (the header for one of the tables was repeated so it was removed).
5 December 1997
Info about windows help version added to section 1.1
Corrections made to info on brush patterns in picture documentation (section 5.1)
Fixed up some small formatting errors in sections 3.4, 3.5, 4.3 and 8.4
5 October 1997
Section 2.7 (version control) updated
Section 6.1 (View format) updated
16 September 1997
I forgot to add the version differences section when I converted all the documentation to HTML. It's there now.
Fixed some problems in the index in section 3.x
31 August 1997
AGI specs is now availabe!
A not about the dates on documents: almost all of the original ASCII text versions of these documents did not have a date on them, so I have put the 'last updated' date to be 31 August 1997, which is when they first appeared in the HTML version of AGI Specs


2.1 General AGI Interpreter Overview
by Lance Ewing
Last updated: 20 August 1997
Retrived from the Internet Archive
 
What is AGI?
AGI stands for Adventure Game Interpreter. It is the old version of Sierra on-lines 3D adventure interpreter.

What games used the AGI interpreter?
Kings Quest 1-3
Kings Quest 4 (256K version)
Space Quest 1, 2
Police Quest
Leisure Suit Larry
Black Cauldron
Mixed Up Mother Goose
Gold Rush
Manhunter 1, 2

There were also a number of demos that were written in AGI.

XMAS animated christmas card
KQ4 demo
PQ1, THEXDER, HELICOPTER SIMULATOR, SQ2, LSL1, and MUMG one program demo

I have been told that a game called Donald Duck's Playground used an early version of AGIv2 as well (v2.001 to be exact).

How many versions of the AGI interpreter were there?
There were three main version of the AGI interpreter. The first version was the one used with KQ1 and KQ2 when they were originally released. The graphics were in CGA but apart from that the games looked very much like the later EGA remakes. The second version is the one we are most familiar with and was used for the majority of the above games. It added support for the 16 colour EGA card but
still kept the old 160x200 resolution that the original games had. The third and final version of the AGI interpreter came out for only a short while before the SCI interpreter hit the scene. There were five games that I know of which used this version. Sierra obvious noticed the increased size of the games and therefore added data compression to this version. There are a few differences in the way the data is stored other than the compression as well, but the data itself still contains exactly the same information. It is
therefore possible to convert a version 3 game into the version 2 format and vice versa.

What files make up an AGI game and what do these files contain?
AGI: This is the main interpreter file. It contains all the routines for the various AGI commands.

AGIDATA.OVL: This file contains various bits of data for the AGI interpreter such as interpreter error messages and jump tables for the AGI commands inside the AGI file.

SIERRA.COM: This is the loader which loads the interpreter file. In some games this will be combined with the AGI file to give one executable often called SIERRA.EXE or maybe the initials of the game.

LOGDIR, VIEWDIR, PICDIR, SNDDIR: These files are basically like an index into the VOL files. They give the location of each of LOGIC, PICTURE, VIEW, and SOUND data within the VOL files. They are therefore called directory files. In version 3 of the interpreter, these files are combined into one file with a header which gives the offset of each part. The name of this single directory file is *DIR where the * is the initials of the game (eg. KQ4DIR, MH2DIR, GRDIR, BCDIR, MH1DIR).

VOL.*: These files contain the main game data. Whereas the AGI interpreter may not change between games, the VOL files will always be different. They look very much like a virtual device which contain many individual files whose positions are given by the directory files. In version 3 games, the VOL files are named *VOL where the * is the initials of the game. (eg. KQ4VOL.0, GRVOL.10, MH2VOL.5).

WORDS.TOK: This file contains a list of all the words that the user may type in during the game. The words are partly compressed and encrypted as well, so you won't be able to see the words if you display the file as you normally would.

OBJECT: This file contains a list of all the inventory items that the user can find in the game. This file is also encrypted but in a different way using the phrase "Avis Durgan". Each object also has associated with it a number that gives the starting room for that object.

*.OVL: Apart from the AGIDATA overlay file which was mentioned above, most of these files are the device drivers for the various display adapters that are supported. They are overlay files which are only brought in depending on which display adapter has been selected. IBM_OBJS.OVL and HGC_OBJS.OVL seem to be more to do with the VIEWs (sprites) though.

What are the LOGIC, PICTURE, SOUND, and VIEW data files?
LOGIC: This data contains the logic scripts that contain the AGI commands which the interpreter runs. All rooms have a single LOGIC script that governs what happens within that room. At the end of a LOGIC file is a text section which contains all the messages that are specific to the functioning of that particular LOGIC script. These are encrypted with the "Avis Durgan" string in the case of version 2 games.

PICTURE: These files contain the picture codes which are used to draw the full screen pictures that you see for each room. The codes are vector based and draw a screen in the manner that the artist originally did. There are two screens store in each PICTURE file: the visual screen and the priority screen. The priority screen contains priority bands and control lines. In version 3 games, this file is not compressed with adaptive LZW as the VIEW, LOGIC, and SOUND files are. The format is also slightly different for codes 0xF0 and 0xF2 in order to slighly compress the data.

VIEW: These files contain all the still props (like objects), actors (like ogres and labion terror beasts), and animated props (like flags blowing in the breeze). All inventory item pictures are a specialized type of VIEW which has a text description tagged to the end of the file. Views are made up of many loops (animation cycles) that are in turn made up of many cels (a single frame of animation).

SOUNDS: These files contain all the musical scores and sound effects which on most machines are one voice over the PC speaker but on some machines, like the PCjr, will be in three voices.

What are the AGI commands?
The AGI commands are what makes up the AGI programming language if you like. Everyones had a muck around with BASIC which is almost always an interpreted language. Well, the AGI commands are like the BASIC statements in BASIC, or like the procedures and functions in Pascal. In both of these languages there are two types of command, those that return a value and those that don't. AGI is much the same in that it has one group of commands that return boolean values and one group which returns nothing. It also has a small subset of keywords (if, else, not, else, or, and, goto, return) which aren't AGI commands as such. At the last count, there were about 181 procedure type commands and about 18 boolean returning function commands (test commands). We only know the names of 169 of the procedure type commands because this is all Sierra has included in their command list used in debug tracing.

Example LOGIC code (from the AGI version of KQ4):

 animate.obj( smoke);
 ignore.horizon( smoke);
 set.view( smoke, v.fish.cabin);
 set.loop( smoke, 1);
 ignore.blocks( smoke);
 position( smoke, 95, 16);
 work = 3;
 step.time( smoke, work);
 cycle.time( smoke, work);
 draw( smoke);
What are the debug modes?
Testers often need some way to achieve certain things quickly so that they can test a certain part of the game. Most AGI games still have the debug code that these testers used when the games were being developed. Of the thirteen AGI games mentioned above, there are only three which I havn't discovered the debug mode in. Most of the games activate their debug modes by pushing the ALT-D key combination. The other games used a magic phrase to enter the debug mode.

Gold Rush: type "bird man".
Kings Quest 3: type "rats ass" (in some versions ALT-D works instead).
Police Quest: type "stink bug".
Space Quest 2: type "backstage" or "dbg".
type "tester" to bring up Rogers screen coordinates.

The following are standard debug mode commands:

TP	Teleport to another room.
SHOW PRIORITY	Show the current rooms priority bands and control lines.
GET OBJECT	Get any inventory item.
GIMME GIMME	Get all inventory items.
SHOW FLAG	Show one of the 256 flags.
SET FLAG	Set one of the 256 flags.
RESET FLAG	Clear one of the 256 flags.
SHOW VAR	Show one of the 256 variables.
SET VAR	Change the value of one of the 256 variables.
POSITION	Change egos position.
SHOW POSITION	Show egos current screen coordinates.
OBJECT NUMBER	Gives a list of all the objects and their object numbers.
OBJECT ROOM	Says which room an object is found in.
ROOM	Says what room number ego is currently in.
SET PRIORITY	Set the priority of ego.
RELEASE PRIORITY	Release the last priority that ego was set to.
Of all the AGI games, it is unknown whether MH1, MH2 and Mixed Up Mother Goose have a debug mode or not. MUMG probably doesn't even though its words.tok file has all the debug words contained in it. Manhunter 2 has some kind of debug mode which allows you to teleport and change variable values because there are text messages in the first LOGIC file along these lines. Manhunter:New York probably has the same debug mode.

Initially we didn't know whether the AGI version of KQ4 had a debug mode or not but we now know that it does have one and it is activated with the ALT-D key combination as is the common practice.

You may be lucky to find a game which allows command tracing. Almost all games have this facility taken out. It is possible to get it to work on some games if you add certain things to the data. What this mode does is to respond to the Scroll-Lock key by displaying a window box which you can step through the test commands that are being executed.

- Most keys step forward one test command.
- The + key steps to the start of the next LOGIC file.

Example:

     =============================
     0: greatern (17, 0)
                 (0, 0)         :F
The line of = characters shows the start of an AGI cycle. The number at the start of a line gives the LOGIC number that is currently being executed. In the case above, the (0, 0) is the numeric value of the two parameters above it, i.e. the 17 in the above line refers to variable 17, and the 0 below it is the current value of variable 17. The 'F' and 'T' characters at the end of a line tell us whether the expression evaluated to be false or true.

Notice that when you reach the start of LOGIC.0 again, all the controlled VIEW objects on the screen are updated. Using this tracing mode is a good way to get a feel for what happens which each cycle of interpretation.

What are the priority bands and control lines?
Okay, you've probably all seen those strange screens that you can activate by typing "SHOW PRIORITY" in the debug modes discussed above. Here's an explanation of what this screen is used for.

PRIORITY BANDS: The screen has about eleven even sized invisible bands across the screen called priority bands. When ego walks up and down the screen, he or she will move from one priority band into the next priority band. The current priority band that ego is in, along with the priority screen that you see when you type "SHOW PRIORITY", is used to determine which parts of ego to draw and which parts not to draw. This is used to give the affect of ego moving behind trees and rocks etc. Everything on the screen has a priority associated with it which is given by its colour on the priority screen. The higher the priority colour, the more priority it has to be drawn.

CONTROL LINES: These are the black, blue, green, and cyan lines that you see drawn on the priority screen. They control what happens to ego when he or she walks past these lines. They might trigger a falling script for the edge of a cliff or a drowning script for the edge of a lake. According to what I've been told, the black control line is a unconditional obstacle, the blue is a conditional obstacle, the green is an alarm line, and the cyan is typically used for water (or something that a VIEW can be confined to being on). The cyan control line will often be a whole filled area. A VIEW object such as a crocodile can be given the object.on.water command and then told to wander. The interpreter will only allow the crocodile to wander over the area that has a control colour of cyan.

What is ego?
Ego is the name given to the main character (eg. Rosella, Roger, Graham). This seems to be the case in all Sierra games. The AGI games have commands which actually use the name ego in the command itself (eg. follow.ego). The later SCI games retain this name.

2.2 How the Interpreter Works
from AGDS docs*
Last updated: 27 January 1998
Retrived from the Internet Archive
 
* This is from the manual of AGDS (Adventure Game Development Toolkit) which contains a good deal of information about the AGI interpreter and its data formats. Translated from Russian by Vassili Bykov, vbykov@cam.org

 
How AGI worls
The AGI interpreter contains:

- 256 (0 - 255) one-byte variables (Var);
- 256 (0 - 255) flags (Flag);
- a number of objects controlled by the interpreter, one of which (the object 0) may be controlled by the player using the keyboard;
- a number of inventory items;
- 12 40-character string variables (string).

Some variables (0 - 26) and flags (0 - 15) are reserved by the interpreter, all others are free to be used by the programmer.

The interpreter provides a common variable and flag space for all programs simultaneously loaded in the memory. The number of objects and things is determined by the OBJECT resource.

Interpreter's actions are described using the commands of the interpreter's language. For example, there are commands to manage objects, load and unload resources, etc. Further we shall consider the commands in detail.

Note!

Any variable, flag, object, string, word, message, etc. has a unique ID number, and numbering of different data types is independent (for example, there can be a variable number 5, a string number 5, and a flag number 5).

 

Resources - the fundamental AGI data type
When we develop a game, we invent the plot, create objects of the game, animate them, develop scenery and a dictionary of words for the dialogue with the player. To describe all of these, resources are used. To create some of the resources, we use utilities included with AGDS, in this case the input of the utilities are resources. [Sounds weird, but that's literally what it says. --VB]

Here is a list of all the existing resources. Resources are used to represent:

colour background drawings (PICTURE resource);
colour animated images (VIEW resource);
sound effects (music, noise) (SOUND resource);
inventory items and other objects (OBJECT resource);
system dictionary for communicating with the user (WORD resource);
programs in internal AGI programming language (LOGIC resource).
General principles of the interpreter operation
Let us now consider the interpreter algorithm and the purpose of reserved variables and flags.

When interpreter starts, LOGIC resource number 0 is loaded in memory. It stays there during the whole play time and determines all the interpreter's actions related to the overall control of the game. The interpreter works in a loop, i.e. all its actions are described by the INTERPRETER WORK CYCLE shown in the block diagram below.

In each cycle the interpreter performs the following basic actions:

time delay;
clears the keyboard buffer;
polls the keyboard and the joystick;
analyses some of the reserved variables and flags (see block diagram);
for all controllable objects for which animate_obj, start_update and draw commands were issued, directions of motion are recalculated;
LOGIC resource 0 is executed, as well as any logics it calls--which, in turn, can call other logics. Depending on the state of variables and flags analyzed at step 4 the number of commands interpreted at stage 4 commands varies from one iteration of the cycle to another depending, for example, on a number of LOGIC resources to be called in the current situation;
tests if the new_room command has been issued;
Then the cycle is repeated.

All logics (programs and subroutines) simultaneously loaded in memory operate on a common set of variables, flags, and strings, each identified by a unique for each data type ID number.

The fact that the interpreter runs in a loop influences the general programming principles and style when programming for AGDS. This makes programming a little unusual and takes a certain time to get used to. For example, many cyclic activities requiring explicit loops in "conventional" programming languages, are executed in the interpreter programs by default, provided the program has a proper structure.

General hints on how to reduce the time to adapt to the interpreter's language are given below, using an educational program "Thunderstorm" as an example. However, this does not reduce the usefulness of analyzing the game programs of Sierra Online, Inc.

 

Interpreter work cycle
                     +---------------------------+
                     |      1. delay time        |
                     +---------------------------+
                                   |
                                   V
                     +----------------------------+
                     |2. clear the keyboard buffer|
                     +----------------------------+
                                   |
                                   V
                     +---------------------------+
                     |      Flag (2) - > 0       |
                     |      Flag (4) - > 0       |
                     +---------------------------+
                                   |
                                   V
                +-------------------------------------+
                | 3. poll keyboard and joystick       |
                +-------------------------------------+
                                   |
                                   V
                +-------------------------------------+
                | If the current mode is              |
                | - program_control, the direction of |
                |   EGO motion <-- var(6).            |
                | - player_control, var (6) --> dir.  |
                |   of EGO motion.                    |
                +-------------------------------------+
                                   |
                                   V
+---------------------------------------------------------------+
| For all objects for which command animate_obj, start_update   |
| and draw were carried out, the recalculation of the direction |
| of movement is performed.                                     |
+---------------------------------------------------------------+
                                   |
                                   V
+---------------------------------------------------------------+
| If the score has changed (var (3)) or the sound has been      |
| turned on or off (Flag (9)), the status line is updated.      |
+---------------------------------------------------------------+
                                   |
                                   +---------+
                                             V
                               +--------------------------+
             +---------------->| 4 Logic 0 is executed    |
             |                 +--------------------------+
             |                               |
             |                               V
             |          +--------------------------------------+
             |          | - Dir. of motion of EGO  <-- var (6) |
             |          | - If score (var (3)) or Flag (9)     |
             |          | have changed their values - update   |
             |          | the status and score (on Var (3));   |
             |          | - Var (5) - > 0;                     |
             |          | - Var (4) - > 0;                     |
             |          | - Flag (5) - > 0!!!!                 |
             |          | - Flag (6) - > 0;                    |
             |          | - Flag (12) - > 0.                   |
             |          +--------------------------------------+
 +----------------------------+               |
 | Execute:                   |               V
 | ~~~~~~~~~~~~~~~~~~~~~~~~   |  +------------------------+
 | - stop_update;             |  | Update all controlled  |
 | - unanimate_all;           |  | objects on the screen. |
 | - destroy all logic        |  +------------------------+
 |   resources except         |                   |
 |   for logic 0;             |                   V
 | - player_control;          |            +--------------+
 | - unblock;                 |            | new_room n   |
 | - set_horizon 36;          |            | or           |
 | - var (1) = var (0);       |            | new_room_v n |
 | - var (0) = n | (var (n)); |            | was issued?  |
 | - var (4) = 0;             |            |              |
 | - var (5) = 0;             |            +-------+------+
 | - var (9) = 0;             |<-----------+  Yes  |  No  |
 | - var (16) = number of     |            +-------+--+---+
 | view assoc. w/EGO;         |                       |
 | - EGO coords from var (2); |                       |
 | - var (2) = 0;             |                       |
 | - flag (2) - > 0;          |                       V
 | - flag (5) - > 1!!!!       |               +--------------+
 | - score < - var (3);       |               | Go to step 1 |
 +----------------------------+               +--------------+
Variables used by the interpreter
On interpreter startup all variables are set to 0.

Var n

0 - Current room number (parameter new_room cmd), initially 0.
1 - Previous room number.
2 - Code of the border touched by EGO:

0 - Touched nothing;
1 - Top edge of the screen or the horizon;
2 - Right edge of the screen;
3 - Bottom edge of the screen;
4 - Left edge of the screen.

3 - Current score.
4 - Number of object, other than EGO, that touched the border.
5 - The code of border touched by the object in Var (4).
6 - Direction of EGO's motion.

                      1
                8     |     2
                  \   |   /
                    \ | /
              7 ------------- 3      0 - the object
                    / | \                is motionless
                  /   |   \
                6     |     4
                      5
7 - Maximum score.
8 - Number of free 256-byte pages of the interpreter's memory.
9 - If = 0, it is the number of the word in the user message that was not found in the dictionary. [I would assume they mean "if != 0", but that's what they say. --VB]

10 - Time delay between interpreter cycles in 1/20 second intervals.
11 - Seconds (interpreter's internal clock)
12 - Minutes (interpreter's internal clock)
13 - Hours (interpreter's internal clock)
14 - Days (interpreter's internal clock)
15 - Joystick sensitivity (if Flag (8) = 1).
16 - ID number of the view-resource associated with EGO.
17 - Interpreter error code (if = 0) [again I would expect this to say "if != 0". --VB]
18 - Additional information that goes with the error code.
19 - Key pressed on the keyboard.
20 - Computer type. For IBM PC it always 0.
21 - If Flag (15) = 0 (command reset 15 was issued) and Var (21) is not equal to 0, the window is automatically closed after 1/2 * Var (21) seconds.
22 - Sound generator type: 1 = PC; 3 = Tandy.
23 - 0:F - sound volume (for TANDY).
24 - 29h.
25 - ID number of the item selected using status command or FF if ESC was pressed.
26 - monitor type

0 - CGA;
2 - Hercules;
3 - EGA.

Flags used by the interpreter
On the interpreter startup all flags are set to 0.

Flag n

0 - EGO base line is completely on pixels with priority = 3 (water surface).
1 - EGO is invisible of the screen (completely obscured by another object).
2 - the player has issued a command line.
3 - EGO base line has touched a pixel with priority 2 (signal).
4 - `said' command has accepted the user input.
5 - The new room is executed for the first time.
6 - `restart_game' command has been executed.
7 - if this flag is 1, writing to the script buffer is blocked.
8 - if 1, Var(15) determines the joystick sensitivity.
9 - sound on/off.
10 - 1 turns on the built-in debugger.
11 - Logic 0 is executed for the first time.
12 - `restore_game' command has been executed.
13 - 1 allows the `status' command to select items.
14 - 1 allows the menu to work.
15 - Determines the output mode of `print' and `print_at' commands:

1 - message window is left on the screen
0 - message window is closed when Enter or Esc key are pressed.
If Var(21) is not 0, the window is closed automatically after 1/2 * Var(21) seconds

2.3 Variable Types Used
by Lance Ewing
Last updated: 31 August 1997
Retrived from the Internet Archive
 
There appear to be a number of data types used as AGI command parameters. These are mentioned below:

(1) Variable
This is the equivalent of a a byte (or unsigned char). It can have a value from 0 to 255. There are 256 variables and in the LOGIC code they are numbered from 0 to 255 and are indentified by their number. The original LOGIC source code that Sierra's programmers wrote would have had textual identifiers for these variables, but when the LOGIC source was compiled into the LOGIC codes, the original variable names were lost. To the interpreter, the variables are known by their index into the
variable table.

Variables are probably the most commonly used type. They feature in arithmetic commands such as addition, multiplication, etc, and a lot of AGI commands have a version that has variable paramaters as an alternative to the normal constant parameter versions.

(2) Flag
Flags are the boolean type of the AGI system. Their value can be either 1 or 0 (true or false). There are 256 flags that are numbered 0 to 255. In the original LOGIC source code, they would have had textual identifiers, but in the compiled LOGIC code they are known only by their index into the interpreters flag table.

Flags are used to indicate when certain things have taken place.

(3) String
According to another source, there are only 12 strings available. I don't know if this is true, but it agrees with the minimum amout of space set aside for strings that I have seen in examining memory usage during a game. However, the majority of AGI games have enough room for exactly 24 strings (see below).

AGI interp. version	Space available for strings
2.089
2.411	12
.....	24
3.002.107
3.002.149	12
Whether the versions that have enough space for 24 strings do infact support 24 strings is not known. Strings are 40 characters long which includes the zero terminator. String number zero is usually the input prompt (e.g. ">" or "]").

(4) Word
Words are the words that the user types in. An input sentence is composed of a number of words. The important words (e.g. for the sentence "look at the tree", "look" and "tree" are important) are assigned to the words variables corresponding to their place in the sentence once unimportant words and punctuation has been taken out. For example, in the earlier example word(1) would be "look" and
word(2) would be "tree". Words can be converted to strings.

(5) Inventory Item
There are a number of AGI commands that refer to inventory items (e.g. get(), drop()). One of the arguments to these commands will represent an inventory item number. In the original LOGIC source text, the programmer would have written things like "get(dagger)" but the interpreter knows them only as an index into the OBJECT table.

(6) Object
There can be a bit of confusion between this type and the inventory item because of the name of the OBJECT file. The OBJECT file has almost nothing to do with what the interpreter generally calls objects. There are a large number of AGI commands that deal with 'objects'. For example,

move.obj
animate.obj
set.view
set.cel
set.loop
draw
etc, etc,

In fact the interpreter calls its usage of the VIEW resource "objects". An object is one usage of a VIEW resource. It is essentially an entry in the object table (or VIEW table/VIEW list). Many objects can use the same VIEW resource for its appearance which can be seen in KQ1 and BC with the crocodile filled moats.

So when an AGI command has an object as a parameter to it, the value of the parameter is an index number into a table of objects that the interpreter is currently controlling.

(7) Message
At the end of every LOGIC file is a message section. There need not be any messages in it, but it will still exist. Messages in LOGIC.0 are global messages whereas all other messages can only be accessed from their own LOGIC code. AGI commands that have messages as parameters refer to a message number in their own LOGIC file. I say that those in LOGIC.0 are global because messages and strings can contain format codes one of which is used to display messages from LOGIC.0

eg.

print("Message 34 in LOGIC.0 is %g34.");

Therefore messages in LOGIC.0 can be displayed by any LOGIC in this way.
 
 2.4 Memory Usage
by Lance Ewing
Last updated: 31 August 1997
Retrived from the Internet Archive
 
The following information gives a rough guide as to how Sierra's AGI interpreter uses its memory. You can view this in operation by using a memory resident program like Game Wizard.

Length of first data area (2 bytes)
Game signature (8 bytes)
Variables (256 bytes)
Flags (256 bits, 32 bytes)
Timers, blocks, and other special AGI variables
Strings (12*40 bytes or 24*40 bytes)
unknown
"Press ENTER to quit" etc
Script command jump table
"Avis Durgan" encryption string
Rest of AGIDATA.OVL is in here
unknown
WORDS.TOK file
OBJECT file
VIEW object table
LOGIC.0
Other loaded resources 

2.5 Game IDs & Loaders
by Lance Ewing, with additions/modifications by Peter Kelly and Anders M Olsson
Last updated: 3 March 1998
 
Since the data formats for the different AGI interpreter versions are mostly identical or easily convertible to each other, we should expect to be able to run one games data with anothers interpreter. This sounds like a reasonable assumption but when you try it, the interpreter rejects the new data. The reason behind this is GAME ID'S.

Every interpreter has got a game ID coded into it and it expects to be given data for that game. Somewhere in the initialization code for each game is a set.game.id. When this command is encountered, the interpreter checks the given game ID and compares it with it's own. If they are not the same, it quits immediately. Presumably the reason for this was to stop people running games with the wrong interpter version, which can cause problems (unless you know what you're doing).

HOW DO WE GET AROUND IT?
Method 1: The hard way

Well, basically we have to find the game ID signature in the AGI interpreter
file and change it to the ID of the game whose data we wish to be executed.

Here are a few examples of some game ID's and the data following them:

Police Quest:

"P"	"Q"	00h	"e"	"I"	"D"	"X"
Mother Goose:

"M"	"G"	00h	"e"	"I"	"D"	"X"
Manhunter 2:

"M"	"H"	"2"	00h	"I"	"D"	"X"
XMAS Demo

"X"	"M"	"A"	"S"	00h	"D"	"X"
Leisure Suit Larry:

"L"	"L"	"L"	"L"	"L"	00h	"X"
The game ID itself is the null terminated string that ends at the 00h. The text that follows it is of no significance, it is simply to fill in the gap although it is useful when searching for the game ID because, as you can see, this text is always "eIDX" or a suffix of it (ie. "IDX", "DX", or "X"). For most games, the game ID is two or three characters which means that you will be able to rely on the "IDX" string being there for these games.

Method 2: The easy way

Using the above method will allow you to run a different game with an interpreter, but you will still only be able to run the game that has the specified game ID. There is another way around this, which involves finding where the set.game.id command is used by the game. This is quiteeasy now that we have programs to edit the logics (such as AGI Studio). What you can usually do is look at the top part of logic 0 and find out what the initialization logic is (usually around 90-100 - you might have to look at a few logics before you find it). Then simply go to that logic, find the set.game.id command, remove it, and recompile the logic. Since the command is not used, the interpreter will not try and compare it with it's own ID, and it won't quit.

The only drawback to using this method is that the saved games no longer have the game ID in their name (so, for example, a savegame would be called SG.1 instead of KQ2SG.1), but this is not a major hassle.

WHY CAN'T I FIND THE GAME ID?
This is because a lot of the AGI files themselves are encrypted. This was probably to give some protection to their product which was quite unique at the time. You can tell the difference between an encrypted AGI file and a non-encrypted AGI file by the first two characters. If they are "MZ" (the EXE file header), then it not encrypted.

The AGI file is decrypted by the loader program. This is usually called SIERRA.COM but can also be named after the game (eg. KQ1.COM). In AGI version 1, the loader was called LOAD. If an AGI game doesn't have a loader, then it shouldn't be encrypted. If an AGI game does have a loader, it does not necessarily mean that the AGI file is encrypted.

The decryption key was not originally embedded in the loader file. If you find a game where the key is embedded in the loader, it is because that game has had copy protection removed. There are several utilities to do that. Anders M Olsson's "SUP" is one of them. The CD re-releases have been unprotected by Sierra in exactly the same fashion.

The loader would read the decryption key from track 6 of the disk, load the executable file, decrypt and run it. Track 6 had a special format that was supposedly impossible to exactly reproduce by a standard PC floppy disk controller.

An interesting note is that when a copy-protected Sierra game asked for the original disk one, you could insert disk one from *any* protected Sierra game. The contents of track 6 were always the same.

But even though track 6 was the same, all games didn't use exactly the same encryption key. The two bytes in the loader, immediately following the string "keyOfs", gave an offset on track 6 from where the key would be loaded.

So, if the decryption string consists of 128 "k" characters, it can actually mean one of two things: Either the AGI file is not encrypted, or the game is still copy-protected.

HOW DOES THE ENCRYPTION WORK?
The LOADER contains a 128 byte string called the decryption key. Here's the process of decryption:

The carry bit is zeroed.
The first 128 bytes of the AGI file are XORed with the decryption key.
The whole key string is rotated one bit to the right, including the carry-bit. (Bit 7 of the first byte is loaded from the carry. Bit 0 of the last byte is placed in the carry, where it will remain until the next rotation.)
The bit that was bit 0 of the last byte (now in carry) is ORed into bit 7 of the first byte.
The next 128 bytes of the AGI file are XORed with the new key. If the end of the AGI file has not been reached, then go back to 3.
WHERE IN THE LOADER IS THE DECRYPTION KEY?
The start of a loader will look something like this:

LOADER v3.0 (c) Copyright Sierra On-Line, Inc. 1987 keyOfs

There are two bytes in between the "keyOfs" string and the start of the description string. If the decryption key consists of 128 "k" characters, then the AGI file is not encrypted (or the game is still copy-protected). If it consists of a whole lot of random looking characters, then it is encrypted.

As an aside, the decryption string is followed immediately by the stack and is usually marked with a whole string of "s" characters. Thus we have "k" for key and "s" for stack. The stack is usually 256 bytes long.

DECRYPTING THE AGI FILE
Decrypting the AGI file is simply a matter of writing a program to read the loader to get the decryption string, and then applying the process mentioned above to the AGI file. Once this has been done, the game ID can be located.

POSSIBILITIES
What this means is that with a few useful AGI utility programs, it is possible to run any set of game data with a compatible AGI interpreter. For example, games that use AGI versions 2.915, 2.917, and 2.936 should be able to be converted into AGIv3 format and run with an AGIv3 interpreter.

'Compatible' as it is used above refers not only to the data differences but also to some AGI command descrepencies. There are about four AGI commands that have changed the number of arguments passed to them as the interpreter developed. This sort of thing is the only real obstacle to running data on another interpreter.

2.6 Processing Parsing the Player Input
from AGDS docs*
Last updated: 31 August 1997
Retrived from the Internet Archive
 
* This is from the manual of AGDS (Adventure Game Development Toolkit) which contains a good deal of information about the AGI interpreter and its data formats. Translated from Russian by Vassili Bykov, vbykov@cam.org

NOTE: This is taken from the description of the said command from section 4.3

Here is how the input is matched. After the player types a message and presses Enter, the input line is processed by the interpreter.

Interpreter removes all punctuation marks.
All characters are converted to lowercase.
All sequences of more than one space are replaced with a single space.
Starting with the first word of the input, the interpreter looks up the vocabulary, trying to find the longest character sequence matching the entered.
If the search is unsuccessful, Var(9) is assigned the number of
the word in the message that failed to match and the processing
ends. If all the words have been assigned some codes:

The Interpreter removes from the sequence of codes all zeros (that means all vocabulary words with zero codes are ignored).
Flag(2) (the user has entered an input line) is set to 1
Flag(4) (`said' command accepted the user input) is set to 0.
If the sequence of code produced by the interpreter is

V(1), V(2),...V(m).

The test is performed as follows:

If Flag(2) = 0 or Flag(4) = 1, return FALSE.

Compare parameters W(i) and codes V(i) as follows:

if W(i) = 1, it matches any V(i);
if W(i) = 9999, it matches the whole remaining input i.e. the codes V(i), V(i+1),...V(m).
Otherwise W(i) should be equal to V(i).

If all elements match, Flag(4) (`said' accepted the user input) is set to
1 and the command returns TRUE. Otherwise, FALSE is returned.

2.7 Version Control
Retrived from the Internet Archive
 
Version 4.0
(If you have a game that is AT ALL different from the ones listed e-mail me mikeph@concentric.net) [Please summit a copy for the Version Control archive])

Note : Dates are from about menu, and not the file date on the files.

If you want to be on my mailing list e-mail me....

Please give this to EVERYBODY.

What's New (v4.0) :
Three new listings : SQ1, SQ2, and LSL1.

Please put this up ASAP, because it is the first release with the correct e-mail address. <sigh>

What's New (v3.0) :
Five new listings : AGIDemo, KQ3, KQ4Demo, SQ1int2426, SQ1int2917

I have added my Space Quest 1 finally (int 2.426).

Also we have the oldest game so far with a "complete date" King's Quest 3 version 1.01

What's New (v2.0) :
AGI Int. Ver. numbers looked up for those which were missing.

Four new listings : BC, SQ1, SQ2D, SQ2F (Thanks guys)

Four new Int. Ver. listings : 2.089, 2.272, 2.915, and 3.002.098

Also be sure to check out manhunter 1 (release date) I checked it 3 times.

As far as why I didn't have Space Quest 1 listed the first time, I lost it, when I find it, it will be added!

Sorted by Game:
Game	Ver.	Int	Int. Ver.	Date
AGID	?.?	AGI	2.915	??/??/??
BC	2.00	AGI	2.439	06/14/87
BC	2.10	AGI	3.002.098	11/10/88
GR	2.01	AGI	3.002.149	12/22/88
KQ1	1.0U	AGI	2.272	Unknown
KQ1	2.0F	AGI	2.425	??/??/87
KQ1	2.0F	AGI	2.917	Unknown
KQ2	2.1	AGI	2.411	Unknown
KQ2	2.2	AGI	2.426	Unknown
KQ2	2.2	AGI	2.917	??/??/87
KQ3	1.01	AGI	2.272	11/08/86
KQ3	2.00	AGI	2.435	05/25/87
KQ3	2.14	AGI	2.936	03/15/88
KQ4	2.0	AGI	3.002.086	07/27/88
KQ4D	?.??	AGI	3.002.102	??/??/??
LSL1	1.00	AGI	2.440	06/01/87
LSL1	1.0	AGI	2.917	06/01/87
MG	?.??	AGI	2.915	Unknown
MH1	1.22	AGI	3.002.102	08/30/88
MH1	1.22	AGI	3.002.107	08/31/88
MH2	3.02B	AGI	3.002.149	07/26/89
MH2	3.03	AGI	3.002.149	08/17/89
PQ1	2.0G	AGI	2.917	12/03/87
SQ1	1.0X	AGI	2.089	Unknown
SQ1	2.2	AGI	2.426	??/??/??
SQ1	2.2	AGI	2.917	??/??/??
SQ1	2.2	AGI	2.917	??/??/87
SQ2	2.0C	AGI	2.915	??/??/87
SQ2	2.0C	AGI	2.917	Unknown
SQ2	2.0D	AGI	2.936	Unknown
SQ2	2.0F	AGI	2.936	Unknown
XM86	?.??	AGI	2.272	Unknown
Sorted by Int. Ver.
Game	Ver.	Int	Int. Ver.	Date
SQ1	1.0X	AGI	2.089	Unknown
KQ1	1.0U	AGI	2.272	Unknown
KQ3	1.01	AGI	2.272	11/08/86
XM86	?.??	AGI	2.272	Unknown
KQ2	2.1	AGI	2.411	Unknown
KQ1	2.0F	AGI	2.425	??/??/87
KQ2	2.2	AGI	2.426	Unknown
SQ1	2.2	AGI	2.426	??/??/??
KQ3	2.00	AGI	2.435	05/25/87
BC	2.00	AGI	2.439	06/14/87
LSL1	1.00	AGI	2.440	06/01/87
AGID	?.?	AGI	2.915	??/??/??
MG	?.??	AGI	2.915	Unknown
SQ2	2.0C	AGI	2.915	??/??/87
KQ1	2.0F	AGI	2.917	Unknown
KQ2	2.2	AGI	2.917	??/??/87
LSL1	1.0	AGI	2.917	06/01/87
PQ1	2.0G	AGI	2.917	12/03/87
SQ1	2.2	AGI	2.917	??/??/??
SQ1	2.2	AGI	2.917	??/??/87
SQ2	2.0C	AGI	2.917	Unknown
KQ3	2.14	AGI	2.936	03/15/88
SQ2	2.0D	AGI	2.936	Unknown
SQ2	2.0F	AGI	2.936	Unknown
KQ4	2.0	AGI	3.002.086	07/27/88
BC	2.10	AGI	3.002.098	11/10/88
KQ4D	?.??	AGI	3.002.102	??/??/??
MH1	1.22	AGI	3.002.102	08/30/88
MH1	1.22	AGI	3.002.107	08/31/88
GR	2.01	AGI	3.002.149	12/22/88
MH2	3.02B	AGI	3.002.149	07/26/89
MH2	3.03	AGI	3.002.149	08/17/89
Sorted by Date
Game	Ver.	Int	Int. Ver.	Date
KQ3	1.01	AGI	2.272	11/08/86
KQ3	2.00	AGI	2.435	05/25/87
BC	2.00	AGI	2.439	06/14/87
LSL1	1.00	AGI	2.440	06/01/87
LSL1	1.0	AGI	2.917	06/01/87
PQ1	2.0G	AGI	2.917	12/03/87
KQ3	2.14	AGI	2.936	03/15/88
KQ4	2.0	AGI	3.002.086	07/27/88
MH1	1.22	AGI	3.002.102	08/30/88
MH1	1.22	AGI	3.002.107	08/31/88
BC	2.10	AGI	3.002.098	11/10/88
GR	2.01	AGI	3.002.149	12/22/88
MH2	3.02B	AGI	3.002.149	07/26/89
MH2	3.03	AGI	3.002.149	08/17/89
 	 	 	 	 
AGID	?.?	AGI	2.915	??/??/??
KQ1	1.0U	AGI	2.272	Unknown
KQ1	2.0F	AGI	2.425	??/??/87
KQ1	2.0F	AGI	2.917	Unknown
KQ2	2.1	AGI	2.411	Unknown
KQ2	2.2	AGI	2.426	Unknown
KQ2	2.2	AGI	2.917	??/??/87
KQ4D	?.??	AGI	3.002.102	??/??/??
MG	?.??	AGI	2.915	Unknown
SQ1	1.0X	AGI	2.089	Unknown
SQ1	2.2	AGI	2.426	??/??/??
SQ1	2.2	AGI	2.917	??/??/??
SQ1	2.2	AGI	2.917	??/??/87
SQ2	2.0C	AGI	2.915	??/??/87
SQ2	2.0C	AGI	2.917	Unknown
SQ2	2.0D	AGI	2.936	Unknown
SQ2	2.0F	AGI	2.936	Unknown
XM86	?.??	AGI	2.272	Unknown
Known Int. Ver.
Int	Int. Ver.	Known Games
AGI	2.089	SQ1
AGI	2.272	KQ1, KQ3, XM
AGI	2.411	KQ2
AGI	2.426	KQ1, SQ1
AGI	2.425	KQ2
AGI	2.435	KQ3
AGI	2.439	BC
AGI	2.440	LSL1
AGI	2.915	AGID, MG, SQ2
AGI	2.917	KQ1, KQ2, LSL1, PQ1, SQ1, SQ1, SQ2,
AGI	2.936	KQ3, SQ2, SQ2
AGI	3.002.086	KQ4
AGI	3.002.098	BC
AGI	3.002.102	KQ4D, MH1
AGI	3.002.107	MH1
AGI	3.002.149	GR, MH2 

2.8 Interpreter Version Differences
by Lance Ewing
Last updated: 27 January 1998
Retrived from the Internet Archive
 
There are a number of different versions of the AGI interpeter but generally the data formats are the same or can easy be converted between each other. The following table is a list of AGI interpreter versions that I know of:

AGIVersion	Interpreter File Size	AGIDATA.OVL Size	Number of Commands	OBJECT File Encrypted	LZW Used In VOL Files
2.089	34305	6656	155	No	No
2.272	34816	6656	161	No	No
2.411	38400	7680	169	Yes	No
2.435	38400	7680	169	Yes	No
2.439	38400	7680	169	Yes	No
2.440	38400	7680	169	Yes	No
2.915	39424	8192	173	Yes	No
2.917	39424	8192	173	Yes	No
2.936	39424	8192	175	Yes	No
3.002.086	40866	8064	177	Yes	Yes
3.002.098	40898	8080	181	Yes	Yes
3.002.102	40898	8080	181	Yes	Yes
3.002.107	40962	8080	181	Yes	Yes
3.002.149	40520	7488	181	Yes	Yes
This table illustrates a number of things.

Firstly, as the interpreter version increased, the number of AGI commands supported increased with it. The last eleven we do not know the names of.
There are two main AGI versions: AGI v2 and AGI v3.
The early AGI v2 games did not encrypt the OBJECT file with the "Avis Durgan" string.
AGI v3 games use adaptive LZW to compress their LOGIC, VIEW, and SOUND files.
COMMAND ARGUMENT NUMBER DESCREPENCIES
There are four commands that have changed the number of arguments that are passed to them. All this information is based on observations made of the above interpreter versions.

(i) The quit command had no arguments for version 2.089 whereas all the others above have one argument.
(ii) The print.at and print.at.v commands had only three arguments for versions 2.089 - 2.400 and four for the other versions.
(iii) Unknown command number 176 had one argument for version 3.002.086 but later versions had no arguments for this command.
AGI VERSION THREE
There are a number of other differences between AGI v3 and AGI v2.

The LOGIC files do not encrypt the text messages with "Avis Durgan" since there is no need to do this because it is compressed anyway.
The PICTURE file format is slightly different for picture codes 0xF0 and 0xF2, i.e. the codes that change the visual colour and priority colour. The difference is that only 4-bits are used to store the colour as opposed to 8-bits in AGI v2.
NUMBER OF STRINGS
There may be some differences in the number of strings supported by some interpreters as well. All interpreters have at least 12 strings. Most interpreters have space for 24 strings but I don't know if the extra space is used for strings or not.

3.1 Directory Files
  by Lance Ewing
Last updated: 31 August 1997
Retrived from the Internet Archive
All AGI games have either one directory file, or more commonly, four. AGI version 2 games will have the files LOGDIR, PICDIR, VIEWDIR, and SNDDIR. Games that use version 3 of the AGI interpreter will have a single file called *DIR where the star is the initials of the game (eg. BC, GR, MH2, MH1, KQ4). This single file is basically the four version 2 files joined together except that it has an 8 byte header giving the position of each directory within the single file.

The directory files give the location of the data types within the VOL files. The type of directory determines the type of data. For example, the LOGDIR gives the locations of the LOGIC files. For a brief introduction to the different data types, read the AGIDOC.TXT document.

Note: In this description and elsewhere in documents written by me, the AGI data called LOGIC, PICTURE, VIEW, and SOUND data are referred to by me as files even though they are part of a single VOL file. I think of the VOL file as sort of a virtual storage device in itself that holds many
files. Some documents call the files contains in VOL files "resources".

Version 2 directories
Each directory file is of the same format. They contain a finite number of three byte entries, no more than 256. The size will vary depending on the number of files of the type that the directory file is pointing to. Dividing the filesize by three gives the maximum file number of that type of data file. Each entry is of the following format:

Byte 1	Byte 2	Byte 3
7	6	5	4	3	2	1	0	7	6	5	4	3	2	1	0	7	6	5	4	3	2	1	0
V	V	V	V	P	P	P	P	P	P	P	P	P	P	P	P	P	P	P	P	P	P	P	P
V = VOL number.
P = Position (offset into VOL file)

The entry number itself gives the number of the data file that it is pointing to. For example, if the following three byte entry is entry number 45 in the SOUND directory file,

12 3D FE

then SOUND.45 is located at position 0x23DFE in the VOL.1 file. The first entry number is entry 0.

If the three bytes contain the value 0xFFFFFF, then the resource does not exist.

Version 3 directories
In the case of version 3 of the AGI interpreter, the LOGDIR, PICDIR, VIEWDIR, and SNDDIR are concatenated together in that order with an eight byte header giving the starting offset of each directory.

Header

Byte	0	1	2	3	4	5	6	7
 	L	L	P	P	V	V	S	S
L = offset of LOGDIR
P = offset of PICDIR
V = offset of VIEWDIR
S = offset of SNDDIR

Each offset is two bytes in length where the first byte is the low byte and the second byte is the high byte as is the case in the whole AGI system. For example, the first two bytes will always be 0x0800 since the header is a fixed size of eight bytes.

The format of each of the individual directory sections then follows as above for AGI v2.

3.2 VOL File Format (version 2)
by Lance Ewing
Last updated: 31 August 1997
Retrived from the Internet Archive
 
VOL files are the main data files for AGI games. They contain four types of data: LOGIC, PICTURE, VIEW, and SOUND data. A VOL file is a collection of a large number of these "resource" files which can be in any order. The directory files determine the start of each resource.

The start of every resource file has a five byte header.

0	1	2	3	4
Signature	Vol	Length
Signature: is always equal to 0x12 : 0x34
Vol: gives the VOL number that the resource is contained in.
Length: is the length of the resource taken from after the header.

The data after the header depends on the type of resource file. These formats are documented elsewhere.

3.3 Version 3 Resource Storage
by Lance Ewing
Last updated: 27 January 1998
Retrived from the Internet Archive
 
AGIv3 stores resources in a slightly different way from AGIv2. The first significant difference is in the length of the resource header which is now seven bytes.

      ________ ________ ________ ________ ________ ________ ________
     |        |        |        |        |        |        |        |
     |  0x12  |  0x34  | VOLNum |    UncompSize   |     CompSize    |
     |________|________|________|________|________|________|________|
VOLNum: Bits 0-3 = VOL file number. Bit 7 = this resource is a PICTURE
UncompSize: Uncompressed resource size [LO-HI]
CompSize: Compressed resource size [LO-HI]

Instead of one resource size as in AGIv2, there are now two sizes. Most of the resources in AGIv3 games are compressed with a form of LZW. Some of them are not though. The interpreter determines whether the resource is compressed by comparing the values of the two sizes given in the header information. If they are equal, then it knows that the resource is stored uncompressed. However, if the sizes do not match, this does not mean that the file is compressed with LZW. If the file is a PICTURE file, then it is stored with its own limited form of compression. This is why the top bit of the third byte in the header is used to tell the interpreter that the resource is a PICTURE file, otherwise it would think that the resource was compressed with LZW.

As far as I can tell, none of the PICTUREs are compressed with LZW. This may well be possible though. It could also be possible for the PICTURE to be totally uncompressed (i.e. it wouldn't use the PICTURE compression method), but I havn't seen any examples of either of the above two cases.

LZW COMPRESSION
The compression used with version 3 games is an adaptive form of LZW. The LZW algorithm is not explained here, but it basically compresses data by representing previous strings by single codes. When these strings are encountered again, the code can be stored instead. The following information states how the AGIv3 algorithm differs from the standard LZW algorithm. There are plenty of places on the net where you can find a description of the LZW algorithm if you are not familiar with it.

AGIv3 uses an adaptive form of LZW that starts by using 9 bit codes and when the code space is full, it progresses on to 10 bits and so on. As with normal LZW, codes 0-255 represent the standard ASCII characters. The next two codes have a special meaning:

- 256 is used as a start over code. The table is cleared, the number of bits set back to 9, and the process begins again with the next code being 258.

- 257 tells the interpreter that it has reached the end of the resource.

Code 256 seems to be the first code stored in all compressed resources. This is probably just to make sure everything is initialized for beginning the compression process. As was mentioned above, the first code used for the LZW table itself is code 258. From there it stores pairs of prefix codes and appended characters for each table entry until it reaches code 512 at which stage it switches to storing the codes using 10 bits and then 11 and so on. It appears that it will never get to 12 bits because code 256 always seems to turn up just before it needs to switch up to 12 bits, i.e. when code 2048 is required. Carl Muckenhoupts decrypt routine for SCI games specifically prevents it from switching to 12 bits anyway. Whether there is ever a case where code 256 does not intervene, it has not yet been determined.

Note: I should point out that Carl and myself both arrived at the above algorithm independently which confirms that the compression used in the early SCI games was identical to that used in AGIv3.

PICTURE COMPRESSION
Pictures in AGI version 3 use a simple form of compression to shrink their size my a tiny amount. It was obviously recognised by the interpreter coders that four bits were being wasted for picture codes 0xF0 and 0xF2. These are the two codes that change the visual and the priority colour respectively. Since there are only 16 colours, there need not be a whole byte set aside for storing the colour. All the picture compression does is store these colours in 4 bits rather than 8.

Example:

Original picture codes: F0 06 F8 12 45 F0 07 F2 05 F8 14 67 ...
Compressed picture code: F0 6F 81 24 5F 07 F2 5F 81 46 7 ...


4.1 LOGIC Resource Format
by Lance Ewing
Last updated: 20 August 1997
Retrived from the Internet Archive
 
INTRODUCTION
At the heart of Sierra's Adventure Game Interpreter is the LOGIC file. These files contain the code that makes up the game. Each room has a logic script that goes with it. This logic script governs what can take place in that room. Here is an example of what the programmer writes when a game is being created.

Example 0: KQ4. Room 7.

    if (said( open, door))       [ must be close enough
    {
       if (posn( ego, 86, 120, 106, 133))
       {
          if (!night)
          {
             if ( door.open)
             {
                print("The door is already open");
             }
             else
             {
                set( game.control);
                set.priority( ego, 11);
                start.update( door);
                end.of.loop( door, door.done);
             }
          }
          else
          {
             print("You can't -- it's locked");
          }
       }
       else
       {
          set( notCloseEnough);
       }
    }
The logic script is not stored like this in the game files though. Instead each AGI command is stored as a code and the resulting data doesn't look much like the above example at all. This document will try to explain each component of a logic script the way it is stored in the actual game data.

 

THE HEADER
The header of each logic script is seven bytes in length for games before 1988. After this date compression seems to have been introduced and the header was subsequently altered. This compression will be discussed at a later stage.

BYTE(S) MEANING

00 - 01 $1234 : signature for the start of a file in the VOL block.
02 VOL file number.
03 - 04 Length of the logic script.
05 - 06 Offset of logic code end and text begin.

All text that can be printed to the screen from within a logic script is stored in an encrypted form at the end of the logic script.

Example 1: KQ1. Room 2.

12 34	Signature
01	VOL.1
5F 06	Length = $065F
BA 02	Text Start = $02BA
 

THE LOGIC CODES
The logic code section starts immediately after the header and continues until the start of the text section has been reached. There are three sets of codes used in a logic script. Most codes will have between one and seven arguments inclusive. This is discussed later on. The first set of codes is the AGI commands themselves and they have the following range:

$00 - $B5 AGI commands. (eg. animate.obj)

The value 181 ($B5) may well be different for each game. Sierra will have added more commands to their set as they went along. The value above is for Manhunter 2 which is one of the last AGI games made. The second set of codes is as follows:

$FF	if
$FE	else (or goto)
$FD	not (!)
$FC	or (||)
At present these are the only high value codes encountered. The 'if' and 'or' codes are more like brackets, ie. the code will be at the start and the end of the section of codes that it refers to. The following example will illustrate this:

Example 2: KQ1. Room 2.

FF	'if' conditions start.
07 07	= isset
05 05	= flag 5
FF	'if' conditions close.
The above translates to:

if (isset(5))

which tests whether flag number 5 is set. The $FF effectively switches the interpreter into a condition checking mode which leads us to the next set of codes which I call the condition codes:

$00 - $12 Condition codes.

The 'isset' condition code was introduced in example 2 above. When the interpreter encounters a $FF it will then interpret the following code values as being in the condition code range until it encounters the next $FF which switches it back into normal AGI command mode. The two bytes immediately following the second $FF determine how many bytes this 'if' statement lasts for before the 'if' is ended. When the second $FF is encountered the interpreter, be it us or the machine, does three things:

1. Reads in the following two bytes.
2. Opens a bracket.
3. Switches to AGI command mode.

Example 3: KQ1. Room 2.

FF 07 05 FF	if (isset(5))
84 00	{ [ For $0084 bytes.
18 00	load.pic(0);
19 00	draw.pic(0);
1B 00	discard.pic(0);
... ...	 
 	} [ Closed. $0084 bytes counted.
Ofcourse, the code inside the brackets is only executed if the 'if' condition is met.

 

THE ELSE COMMAND AND MORE ON BRACKETS
The else statement will always continue after an 'if' bracket block. This next feature is important and has caused a number of hassles in the past. When an 'else' statement follows an 'if', then the bracket distance given after the 'if' statement WILL BE THREE BYTES LONGER (this is a consequence of the way the interpreter handles if and else codes which is discussed later).

Here's an example:

 if (isset(231)) {                        FF 07 E7 FF 05 00
   printf("The door is already open.");   65 0F
 }
 else {                                   FE 11 00
   set(36);                               0C 24
   prevent.input();                       77
   start.update(5);                       3B 05
   assignn(152, 3);                       03 98 03
   cycle.time(5, 152);                    4C 05 98
   end.of.loop(5, 232);                   49 05 E8
   sound(70, 154);                        63 46 9A
 }
Usually you would expect the bracket distance to be 0x0002 but in the above case it is clearly 0x0005 which illustrates the difference between a straight 'if' statement and an 'if..else' structure. The situation is the same for nested 'if..else' structures.

The 'else' statements themselves are a lot like 'if' statements except that they're test condition is given after the 0xFE code but is instead the inverse of the condition given by the above 'if' statement. Only the bracket distance is given after the 0xFE code and then the AGI command clock that the 'else' statement encompasses.

 

TEST CONDITIONS
Conditions can be one of the following types:

FF 07 05 FF	One condition tested, ie. isset(5)
FF FD 07 05 FF	One condition NOTed, ie. !isset(5)
FF 07 05 07 06 FF	Multiple conditions, ANDed.
FF FC 07 05 07 06 FC FF	Multiple conditions ORed.
FF FC 07 06 07 06 FC FD 07 08 FF	Combination
These conditions translate to:

if (isset(5))
if (!isset(5))
if (isset(5) && isset(6))
if (isset(5) || isset(6))
if ((isset(5) || isset(6)) && !isset(7))

If multiple boolean expressions are grouped together, then there respective values are ANDed together. If multiple boolean expressions are grouped together and then surrounded by a pair of $FC codes, then their values are ORed together.

The $FD code only applies to the following condition code whose boolean
value it inverts.

ARGUMENTS
You may well be asking how the interpreter knows how many arguments each code has and what type of argument each argument is. This information is stored in a file called AGIDATA.OVL (PC version). Inside this file there is a table which contains four bytes for each AGI command and condition code. These four bytes are interpreted as follows:

00 - 01	Pointer to the machine code implementation contained in the file AGI.
02	Number of arguments.
03	The type of arguments.
The type of arguments value is interpreted as follows:

BIT	7	6	5	4	3	2	1	0
command(	arg1,	arg2,	arg3,	arg4,	arg5,	arg6,	arg7);	(unknown)
bit = 0 argument is interpreted as a number.
bit = 1 argument is interpreted as a variable.

It is unknown what bit 0 does since no AGI command or AGI condition code
has more than seven arguments.

Examples:

$80 Says that the commands first argument is a variable.
$60 Says that the second and third arguments are variable numbers.

 

VARIABLES
AGI games appear to have 255 variables. The first twenty or so variables will probably have a set meaning. For example, variable zero usually contains the current room number no matter what game is being played.

 

FLAGS
AGI games also have 255 flags. These flags can have either a true or false value. They are usually used to store whether something has taken place or not. For example, in KQ4 the flag 'night' is used to say whether night has arrived yet.

 

THE TEXT SECTION
The text section of a logic script contains all the strings that can be displayed by that logic script. These strings are encrypted by xoring every eleven bytes with the string "Avis Durgan".

Example 4: KQ1. Room 2.

    if (said(look, alligators))
    {
       print("The alligators are swimming in the moat.");
    }
In the above example, the print statement is represented as:

65 08

The $08 is the number given to the string and corresponds to its position in the list of strings at the end of the logic script.

The format of the text section is as follows:

00	Number of messages
01 - 02	Pointer to end of messages
03 - 04	A list of offsets which point to each of the messages. The first offset naturally enough points to the start of the textual data.
...	 
??	Start of the text data. From this point the messages are
encrypted with Avis Durgan. In their unencrypted form, each
message is separated by a 0x00 or null value.
 

MACHINE CODE IMPLEMENTATION
The machine code for each AGI statement is found in the AGI file. This is the AGI interpreter itself. The data in the AGIDATA.OVL file is used to find the start of the implementation for an AGI statement. Below are a couple of examples:

Example 5: MH2. equaln.

    ;equaln   (eg.   if (work = 3)   )
    0D71 AC            LODSB                       ;get variable number
    0D72 32FF          XOR     BH,BH
    0D74 8AD8          MOV     BL,AL
    0D76 AC            LODSB                       ;get test number
    0D77 3A870900      CMP     AL,[BX+0009]        ;test if var = number
    0D7B B000          MOV     AL,00               ;return 0 if not equal
    0D7D 7502          JNZ     0D81
    0D7F FEC0          INC     AL                  ;return 1 if equal
    0D81 C3            RET
Example 6: MH2. equalv.

    ;equalv  (eg.   if (work = maxwork)   )
    0D82 AC            LODSB                       ;get first var number
    0D83 32FF          XOR     BH,BH               ;clear bh
    0D85 8AD8          MOV     BL,AL               ;BX = variable number
    0D87 8AA70900      MOV     AH,[BX+0009]        ;get first var value
    0D8B AC            LODSB                       ;get second var number
    0D8C 8AD8          MOV     BL,AL
    0D8E 32C0          XOR     AL,AL               ;return 0 if not equal
    0D90 3AA70900      CMP     AH,[BX+0009]        ;compare variables
    0D94 7502          JNZ     0D98
    0D96 FEC0          INC     AL                  ;return 1 if equal
    0D98 C3            RET
These two examples show the difference between how numbers and variables are dealt with. In the case of a variable, the variables number is used as an index into the table of variable values to get the value which is being tested. It appears that the variable table is at offset $0009 in the data segment.

 

HOW THE INTERPRETER HANDLES LOGIC CODE
Now that you know a bit about what the actual code looks like once it has been converted into the LOGIC game data, we will now look at how these codes are interpreted by the interpreter. The following ASM code is the actual code from MANHUNTER:SAN FRANCISCO. There are some calls to routines which aren't displayed. Take my word for it that they do what the comment says. For those of you who can't follow whats going on, I'll explain the interpretation in steps after the code block.

;Decoding a LOGIC file. 
1E6C:2EF2 56            PUSH	SI
1E6C:2EF3 57            PUSH	DI                                 
1E6C:2EF4 55            PUSH	BP                                 
1E6C:2EF5 8BEC          MOV	BP,SP                              
1E6C:2EF7 83EC02        SUB	SP,+02                             
1E6C:2EFA 8B7608        MOV   SI,[BP+08]    ;SI -> start of LOGIC script.
1E6C:2EFD 8B7406        MOV   SI,[SI+06]    ;Skip first 6 bytes (header).
1E6C:2F00 AC            LODSB               ;Get next byte in LOGIC file.
1E6C:2F01 84C0          TEST  AL,AL         ;Is code a zero?
1E6C:2F03 7414          JZ 2F19             ;If so, jump to exit.
1E6C:2F05 3CFF          CMP   AL,FF         ;If an opening 'if' code is found
1E6C:2F07 7419          JZ 2F22             ;jump to 'if' handler.
1E6C:2F09 3CFE          CMP   AL,FE         ;If an 'else' has not been found
1E6C:2F0B 7505          JNZ   2F12          ;jump over else/branch.
1E6C:2F0D AD            LODSW               ;Get word (bracket distance)
1E6C:2F0E 03F0          ADD   SI,AX         ;Add to SI. Skip else code.
1E6C:2F10 EBEE          JMP   2F00          ;Go back to get next byte.
1E6C:2F12 E8A8D6        CALL  05BD          ;Execute AGI command.
1E6C:2F15 85F6          TEST  SI,SI         ;
1E6C:2F17 75E8          JNZ   2F01          ;Jump back to top.
1E6C:2F19 8BC6          MOV	AX,SI                              
1E6C:2F1B 83C402        ADD	SP,+02                             
1E6C:2F1E 5D            POP	BP                                 
1E6C:2F1F 5F            POP	DI                                 
1E6C:2F20 5E            POP	SI                                 
1E6C:2F21 C3            RET

;Handler for 'if' statement.
;BH determines if its in an OR bracket (BH=1 means OR).
;BL determines the nature of the evalutation (BL=1 means NOT)
1E6C:2F22 33DB          XOR	BX,BX                              
1E6C:2F24 AC            LODSB               ;Get next byte
1E6C:2F25 3CFC          CMP   AL,FC         ;If less than 0xFC, then
1E6C:2F27 721C          JB 2F45             ;jump to normal processing.
1E6C:2F29 7508          JNZ   2F33          ;If greater, jump to 'if' close.
1E6C:2F2B 84FF          TEST  BH,BH         ;(Could BH be the evaluation reg?
1E6C:2F2D 7551          JNZ   2F80          ;or whether its the second FC?
1E6C:2F2F FEC7          INC   BH            ;
1E6C:2F31 EBF1          JMP   2F24          ;Go back to get next byte.                     
1E6C:2F33 3CFF          CMP   AL,FF         ;Is the code for an 'if' close?
1E6C:2F35 7505          JNZ   2F3C          ;If not, jump to 'not' test.
1E6C:2F37 83C602        ADD   SI,+02        ;
1E6C:2F3A EBC4          JMP   2F00          ;
1E6C:2F3C 3CFD          CMP   AL,FD         ;Is the code for a 'not'?
1E6C:2F3E 7505          JNZ   2F45          ;If not, jump to test command.
1E6C:2F40 80F301        XOR   BL,01         ;
1E6C:2F43 EBDF          JMP   2F24          ;Go back to get next byte.
1E6C:2F45 53            PUSH  BX            ;BX = test conditions?? 
1E6C:2F46 E8E8DD        CALL  0D31          ;Evaluate separate test command.
1E6C:2F49 5B            POP   BX            ;
1E6C:2F4A 32C3          XOR   AL,BL         ;Toggle the result for NOT.
1E6C:2F4C B300          MOV   BL,00         ;
1E6C:2F4E 7506          JNZ   2F56          ;If true jump to 2F56.
1E6C:2F50 84FF          TEST  BH,BH         ;If BH=0 then not in OR and
1E6C:2F52 742C          JZ 2F80             ;test is truely false.
1E6C:2F54 EBCE          JMP   2F24          ;Otherwise evaluate next OR.
1E6C:2F56 84FF          TEST  BH,BH         ;Are we in OR mode?
1E6C:2F58 7424          JZ 2F7E             ;If not, continue with testing.
1E6C:2F5A 32FF          XOR   BH,BH         ;If so, then we will skip the
1E6C:2F5C 32E4          XOR   AH,AH         ;rest of the tests in the OR
1E6C:2F5E AC            LODSB               ;bracket since the first is true.
1E6C:2F5F 3CFC          CMP   AL,FC         ;OR: Waiting for closing OR.
1E6C:2F61 741B          JZ 2F7E             ;If OR found, then continue testing.
1E6C:2F63 77F9          JA 2F5E             ;
1E6C:2F65 3C0E          CMP   AL,0E         ;If 'said' then goto said handler
1E6C:2F67 7507          JNZ   2F70          ;else goto normal handler
1E6C:2F69 AC            LODSB               ;Work out number of words in said
1E6C:2F6A D1E0          SHL   AX,1          ;and jump over them.
1E6C:2F6C 03F0          ADD   SI,AX         ;
1E6C:2F6E EBEE          JMP   2F5E          ;
1E6C:2F70 8BF8          MOV   DI,AX         ;Jumps over arguments.
1E6C:2F72 D1E7          SHL   DI,1          ;
1E6C:2F74 D1E7          SHL   DI,1          ;
1E6C:2F76 8A856407      MOV   AL,[DI+0764]  ;Load up the number of arguments
1E6C:2F7A 03F0          ADD   SI,AX         ;Add to the execution pointer
1E6C:2F7C EBE0          JMP   2F5E          ;
1E6C:2F7E EBA4          JMP	2F24

;Test is false.
;This routine basically skips over the rest of the codes until it finds the
;closing 0xFF at which point it will load the following two bytes and add
;them to the execution pointer SI.
1E6C:2F80 32FF          XOR   BH,BH         
1E6C:2F82 32E4          XOR	AH,AH                              
1E6C:2F84 AC            LODSB               ;
1E6C:2F85 3CFF          CMP   AL,FF         ;If the closing 0XFF is found,
1E6C:2F87 741D          JZ 2FA6             ;jump 2FA6.
1E6C:2F89 3CFC          CMP   AL,FC         ;If greater than FC,
1E6C:2F8B 73F7          JNB   2F84          ;get next byte.
1E6C:2F8D 3C0E          CMP   AL,0E         ;If 'said' then goto said handler
1E6C:2F8F 7507          JNZ   2F98          ;else goto normal handler.
1E6C:2F91 AC            LODSB               ;Work out number of words in said
1E6C:2F92 D1E0          SHL   AX,1          ;and jump over them.
1E6C:2F94 03F0          ADD	SI,AX                              
1E6C:2F96 EBEC          JMP	2F84                               
1E6C:2F98 8AD8          MOV   BL,AL         ;Jump over arguments.
1E6C:2F9A D1E3          SHL	BX,1                               
1E6C:2F9C D1E3          SHL	BX,1                               
1E6C:2F9E 8A876407      MOV   AL,[BX+0764]  ;Load up the number of arguments.
1E6C:2FA2 03F0          ADD   SI,AX         ;Add to the execution pointer.
1E6C:2FA4 EBDE          JMP	2F84                               
1E6C:2FA6 AD            LODSW	                                   
1E6C:2FA7 03F0          ADD   SI,AX         ;Skip over if (includes 3 else bytes)
1E6C:2FA9 E954FF        JMP	2F00
SITUATION 1: Okay, every LOGIC file starts in normal AGI command execution mode. In this routine, if the code is below 0xFC, then it is presumed to be an AGI command. It will then call the main command execution routine which will jump to the relevant routine for the specific command using the jump table stored in AGIDATA.OVL. The command is performed and it returns to the main execution routine where it loops back to the top and deals with the next code in the LOGIC file.

SITUATION 2: If the code is an 0xFF code, then if jumps to the 'if' statement handler. In this routine is basically assesses whether the whole test condition evaluates to true or to false. It does this by treating each test separately and calling the relevant test command routines using the jump table in the AGIDATA.OVL file. Each test command routine will return a value in AL which says whether it is true or not (AL=1 is true, AL=0 is false). Depending on the NOTs and ORs, the whole expression is evaluated. If at any stage during the evaluation the routine decides that the expression will be false, it exits to another routine which skips the rest of the 'if' statement and
then adds the two byte word following the closing 0xFF code to the execution pointer. This usually has the affect of jumping over the 'if' block of code. If the 'if' handler gets to the ending 0xFF then it knows the expression is true simply because it hasn't exited out of the routine yet. At this stage it jumps over the two bytes following the closing 0xFF and then goes back to executing straight AGI commands.

SITUATION 3: If in the normal execution of AGI commands, the code 0xFE is encountered, a very simple action takes place. The two bytes which follow form a 16-bit twos complement value which is added to execution pointer. This is all it does. Previously we said that the 0xFE code stood for the 'else' statement which is in actual fact correct for over 90% of the time, but the small number of other occurrences are best described as 'goto' statements. If you're confused by this, the following example will probably explain things.

 

Example:

 if (said( open, door)) {
    [ first block of AGI statements
 }
 else {
    [ second block of AGI statements
 }
The above example is how the original coder would have written the AGI code. If we now look at the following example, it is not hard to see that it would achieve the same ting.

 if (!said( open, door)) goto label1;
    [ first block of AGI statements
    goto label2:

 label1:
    [ second block of AGI statements

 label2:
This is exactly how all if's and else's are implemented in the LOGIC code. The 'if' statement is a conditional branch where the branch is taken if the condition is not met, while the 'else' statement is a nonconditional jump. If a 0xFE code appears in the middle of some AGI code and wasn't actually originally coded as an 'else', then it was most likely a 'goto' statement.

 

THE 'SAID' TEST COMMAND
The above ASM code does raise a very important point. The 'said' command can have a variable number of arguments. Its code is 0x0E, and the byte following this byte gives the number of two byte words that follow as parameters.

Examples:

if (said( marble)) FF 0E 01 1E 01 FF
if (said( open, door)) FF 0E 02 37 02 73 00 FF

In the above examples, the values 0x011E, 0x0237, and 0x0073 are just random word numbers that could stand for the words given.

 

INNER LOOPS
At first I almost totally discarded the existence of loops in the AGI code because it seemed to me that execution of the LOGIC file continually looped. Loop code like 'while', 'do..while', and 'for' statements wouldn't be needed because you could just use a variable to increment with each pass and an 'if' statement to test the value of the variable and take action if it was withing
the desired range.

Example:

  if (greatern(30, 45) && lessn(30, 55)) {
     print("You're in the hot zone!);
     increment(30);
  }
I have found evidence of this sort of thing taking place which means that they must loop over continuously. I don't know whether this is something that the interpreter does itself or whether it is part of the AGI code, eg. at the end of one LOGIC file it calls another which then calls the first one again. With the existence of the conditional branching and unconditional branching nature of the 'if' and 'else' statement, it is easy to see that some of the structures such as 'do..while' can infact be coded into LOGIC code.

Example:

FF FD 0D FF 03 00 FE F7 FF

  do {
  } while (!havekey);
The above translation is a simple one which is taken from SQ2. The value 0xFFF7 is the twos complement notation for -9 which is the exact branching value to take the execution back to the start of the 'if' statement. If the above example had AGI code between the 0x00 and the 0xFE, then there would be code within the brackets of the 'do..while' structure. I don't know whether the original AGI coders used these statements or used 'goto' statements to achieve the same result.

 

NEW INFORMATION ON LOGIC INTERPRETATION
It has now come to light that LOGIC.0 is run over and over again with each interpretation cycle. The other LOGICs that have been loaded will only get executed if LOGIC.0 calls them directly or indirectly (i.e. LOGICs called from LOGIC.0 can call other LOGICs and so on).

I have also become aware that code 0x00 can basically be throught of as the command "return". If LOGIC.0 calls another logic, the execution will return to LOGIC.0 when the 0x00 code is encountered.

It is also possible to set the entry point for a LOGIC file. The set.scan.start() command makes the entry point of the LOGIC file being executed equal to the position of the command following set.scan.start(). This means that the next time the LOGIC file is executed, execution begins at that point. The reset.scan.start() command sets the entry point back to the start of the LOGIC.

 

THE AGI LANGUAGE
The following is a little bit about what we know of commands and how they function. The commands can be grouped together depending on what they deal with. For example,

load.view	Load a VIEW from a VOL file into memory.
load.view.v	Load the VIEW number contained in the given variable.
discard.view	Discard a VIEWs data from memory.
set.view	Assign a view to an internal view number.
set.view.v	Same but the variable contains the number.
Clearly all of these commands deal with VIEWs. Likewise there are groups of PICTURE commands, SOUND commands, and LOGIC commands. A large group of commands deal with animating the VIEWs.

set.loop	Set which loop (or sequence within the VIEW) to use.
set.cel	Set which cel (or individual frame) to display.
animate.obj	Animates a view (or object) as opposed to just showing it (show.obj).
step.time	Determine the speed of the animation.
cycle.time	 
draw	Actually draws the VIEW with the setting it was given.
start.update	Starts the animation of a previously inanimate object.
end.of.loop	Waits for the loop of animation to complete.
You can now get read a description of how all the AGI commands function thanks to a group of Russian people who have been working on a similar project to ours. The English translation of this document should be available where you found this document.

4.2 LOGIC Syntax
by Peter Kelly
Last updated: 27 January 1998
Retrived from the Internet Archive
 
This is the "official" logic syntax that has been decided on. It is not the same syntax as Sierra used. All logic decoders and compilers should comply with this syntax, so that programmers can be sure that code they produce can be used properly with any program.

Action Commands
Normal action commands are specified by the command name followed by brackets which contain the arguments, separated by commas. A semicolon is placed after the brackets. The brackets are required even if there are no arguments. The arguments given must have the correct prefix for that type of argument as explained later in this document (this is to make sure the programmer does not use a var, for example, when they think they are using a flag).

assign.v(v50,0);

program.control();
Multiple commands may be placed on the one line:

reset(f6); reset(f7);
Substitutions for the following action commands are available:

increment(v30);	v30++;
decrement(v30);	v30--;
assignn(v30,4);	v30 = 4;
assignv(v30,v32);	v30 = v32;
addn(v30,4);	v30 = v30 + 4;	or	v30 += 4;
addv(v30,v32);	v30 = v30 + v32;	or	v30 += v32;
subn(v30,4);	v30 = v30 - 4;	or	v30 -= 4;
subv(v30,v32);	v30 = v30 - v32;	or	v30 -= v32;
mul.n(v30,4);	v30 = v30 * 4;	or	v30 *= 4;
mul.v(v30,v32);	v30 = v30 * v32;	or	v30 *= v32;
div.n(v30,4);	v30 = v30 / 4;	or	v30 /= 4;
div.v(v30,v32);	v30 = v30 / v32;	or	v30 /= v32;
lindirectn(v30,4);	*v30 = 4;
lindirectv(v30,v32);	*v30 = v32;
rindirect(v30,v32);	v30 = *v32;
IF structures and test commands
An if structure looks like this:

if (<test commands>) {
  <action commands>
}
or like this :

if (<test commands>) {
  <action commands>
}
else {
  <more action commands>
}
Carriage returns are not necessary:

if (<test commands>) { <action Commands> } else { <more action commands> }
Test commands are coded like action commands except there is no semicolon. They are separated by && or || for AND or OR.

if (isset(f5) &&
    greatern(v5,6)) { ......
Again, carriage returns are not necessary within the if statement:

if (lessn(v5,6) && (greatern(v5,2)) { .......

if (isset(f90) && equalv(v32,v34)
    && greatern(v34,20)) { .......
A ! placed in front of a command signifies a NOT.

if (!isset(f7)) {
  ......
Boolean expressions are not necessarily simplified so they must follow the rules set down by the file format. If test commands are to be ORred together, they must be placed in brackets.

if ((isset(f1) || isset(f2)) {
  ......

if (isset(f1) && (isset(f2) || isset(f3))) {
  ......

if (isset(1) || (isset(2) && isset(3))) {    is NOT legal
Depending on the compiler, simplification of boolean expressions may be supported, so the above may not apply in all cases (although if these are rules are followed then the logic will work with all compilers).

Substitutions for the following test commands are available:

equaln(v30,4)	v30 == 4
equalv(v30,v32)	v30 == v32
greatern(v30,4)	v30 > 4
greaterv(v30,v32)	v30 > v32
lessn(v30,4)	v30 < 4
lessv(v30,v32)	v30 < v32
!equaln(v30,4)	v30 != 4
!equalv(v30,v32)	v30 != v32
!greatern(v30,4)	v30 <= 4
!greaterv(v30,v32)	v30 <= v32
!lessn(v30,4)	v30 >= 4
!lessv(v30,v32)	v30 >= v32
Also, flags can be tested for by just using the name of the flag:

if (f6) { .....

if (v7 > 0 && !f6) { .....
Argument types
There are 9 different types of arguments that commands use:

Number	(no prefix)
Var	(prefix "v")
Flag	(prefix "f")
Message	(prefix "m")
Object	(prefix "o")
Inventory Item	(prefix "i")
String	(prefix "s")
Word	(prefix "w")
Controller	(prefix "c")
The said test command uses it's own special arguments which will be described later.

Each of these types of arguments is given by the prefix and then a number from 0-255, e.g. v5, f6, m27, o2.

The word type is words that the player has typed in, not words that are stored in the WORDS.TOK file. Strings are the temporary string variables stored in memory, not to be confused with messages (that are stored in the logic resources). Controllers are menu items and keys.

Compilers can enforce type checking, so that the programmer must use the correct prefix for an argument so that they know they are using the right type. Decoders should display arguments with the right type.

move.obj(so4,80,120,2,f66);

if (obj.in.box(so2,30,60,120,40)) { .....
A complete list of the commands and their argument types is available as part of AGI Specs.

Messages and inventory items may be given in either numerical text format:

print("He's not here.");

print(m12);

if (has("Jetpack")) { .....

if (has(io9)) { .....
Messages can also be split over multiple lines:

print("This message is split "
      "over multiple lines.");
Quote marks must be used around messages and object names. This is important because some messages or object names may contain brackets or commas, which could confuse the compiler. This is also the case for the said command which will be described shortly.

if (has("Buckazoid(s)")) { .....        // no ambiguity here about where
                                        // the argument ends
If quote marks are part of the message or inventory object, a \ should be placed in front of these. To use a \, \\ should be used. \n can also be used for a new line.

The said test command uses different parameters to all the other commands. Where as the others use 8 bit arguments (0-255), said takes 16 bit arguments (0-65535). Also, the number of arguments in a said command can vary. The numbers given in the arguments are the word group numbers from the WORDS.TOK file.

if (said(4,80)) { .....
Words can also be given in place of the numbers:

if (said("look")) { .....

if (said("open","door")) { .....
Quote marks must also be used around the words.

Labels and the goto command
Labels are given like this:

Label1:
The label name can contain letters, numbers, and the characters "_" and ".". No spaces are allowed.

The goto command takes one parameter, the name of a label.

goto(Label1);
Comments
There are three ways that comments can be used.

// - rest of line is ignored
[ - rest of line is ignored
/* Text between these are ignored */

The /*...*/ can be nested:

/* comment start
  print("Hello");    // won't be run
  /*                 // a new comment start (will be ignored!)
    v32 = 15;        // won't be run
  */                 // uncomments the most inner comment
  print("Hey!");     // won't be run, still inside comments
*/                   // uncomments
Defines
To give vars, flags etc. proper names the #define command is used. The name of the define is given followed by the define value:

#define ego o0
#define room_descr "This is a large hall with tall pillars down each side."
Then the define name can be used in place of the define value:

draw(ego);
print(room_descr);
Define names can only be used in arguments of commands (including gotos and the v0 == 3 type syntax), although some compilers may allow you to use them anywhere.

Defines must be defined in the file before they are used.

The define name can contain letters, numbers, and the characters "_" and ".". No spaces are allowed.

Including files
You can include another file in your logic source code by using the #include command:

#include "file.txt"
When the compiler encounters the above line, it will replace it with the contents of file.txt.

It is a good idea to have all the defines that you need for multiple logics in an #include file, so if you need to change the define value you only have to do it once (although you will need to recompile all logics that use that define).

More on messages
In some cases you may want to assign a specific number to a message so you can refer to it in other places. This is done by using the #message command, followed by the number of the message then the message itself:

#message 4 "You can't do that now."
Then you can give the message number as the parameter in commands:

print(m4);
Or embed the message in commands as normal and the number you assigned to it before will be used:

print("You can't do that now.");
#message can be used anywhere in the file, so you do not have to set the message before you use it.

The return command
The return command is just a normal action command (number 0), with no arguments. This must be the last command in every logic.

4.3 Command List & Argument Types
by Peter Kelly
Last updated: 3 March 1998
Retrived from the Internet Archive
 
This is a list of all AGI commands and their argument types/. The function and name of some of these is not yet known. Check out agicommands.pas the "sample code" section for a delphi/pascal unit containing this information.

Text commands
No.	Name	No.	arg 1	arg 2	arg 3	arg 4	arg 5	arg 6	arg 7
01	equaln	2	var	num	 	 	 	 	 
02	equalv	2	var	var	 	 	 	 	 
03	lessn	2	var	num	 	 	 	 	 
04	lessv	2	var	var	 	 	 	 	 
05	greatern	2	var	num	 	 	 	 	 
06	greaterv	2	var	var	 	 	 	 	 
07	isset	1	flag	 	 	 	 	 	 
08	issetv	1	var	 	 	 	 	 	 
09	has	1	I obj	 	 	 	 	 	 
0A	obj.in.room	2	I obj	var	 	 	 	 	 
0B	posn	5	S obj	num	num	num	num	 	 
0C	controller	1	cntrl	 	 	 	 	 	 
0D	have.key	0	 	 	 	 	 	 	 
0E	said	-	 	 	 	 	 	 	 
0F	compare.strings	2	string	string	 	 	 	 	 
10	obj.in.box	5	S obj	num	num	num	num	 	 
11	center.posn	5	S obj	num	num	num	num	 	 
12	right.posn	5	S obj	num	num	num	num	 	 
Action commands
No.	Name	No.	arg 1	arg 2	arg 3	arg 4	arg 5	arg 6
00	return	0	 	 	 	 	 	 
01	increment	1	var	 	 	 	 	 
02	decrement	1	var	 	 	 	 	 
03	assignn	2	var	num	 	 	 	 
04	assignv	2	var	var	 	 	 	 
05	addn	2	var	num	 	 	 	 
06	addv	2	var	var	 	 	 	 
07	subn	2	var	num	 	 	 	 
08	subv	2	var	var	 	 	 	 
09	lindirectv	2	var	var	 	 	 	 
0A	rindirect	2	var	var	 	 	 	 
0B	lindirectn	2	var	num	 	 	 	 
0C	set	1	flag	 	 	 	 	 
0D	reset	1	flag	 	 	 	 	 
0E	toggle	1	flag	 	 	 	 	 
0F	set.v	1	var	 	 	 	 	 
10	reset.v	1	var	 	 	 	 	 
11	toggle.v	1	var	 	 	 	 	 
12	new.room	1	num	 	 	 	 	 
13	new.room.v	1	var	 	 	 	 	 
14	load.logics	1	num	 	 	 	 	 
15	load.logics.v	1	var	 	 	 	 	 
16	call	1	num	 	 	 	 	 
17	call.v	1	var	 	 	 	 	 
18	load.pic	1	var	 	 	 	 	 
19	draw.pic	1	var	 	 	 	 	 
1A	show.pic	0	 	 	 	 	 	 
1B	discard.pic	1	var	 	 	 	 	 
1C	overlay.pic	1	var	 	 	 	 	 
1D	show.pri.screen	0	 	 	 	 	 	 
1E	load.view	1	num	 	 	 	 	 
1F	load.view.v	1	var	 	 	 	 	 
20	discard.view	1	num	 	 	 	 	 
21	animate.obj	1	S obj	 	 	 	 	 
22	unanimate.all	0	 	 	 	 	 	 
23	draw	1	S obj	 	 	 	 	 
24	erase	1	S obj	 	 	 	 	 
25	position	3	S obj	num	num	 	 	 
26	position.v	3	S obj	var	var	 	 	 
27	get.posn	3	S obj	var	var	 	 	 
28	reposition	3	S obj	var	var	 	 	 
29	set.view	2	S obj	num	 	 	 	 
2A	set.view.v	2	S obj	var	 	 	 	 
2B	set.loop	2	S obj	num	 	 	 	 
2C	set.loop.v	2	S obj	var	 	 	 	 
2D	fix.loop	1	S obj	 	 	 	 	 
2E	release.loop	1	S obj	 	 	 	 	 
2F	set.cel	2	S obj	num	 	 	 	 
30	set.cel.v	2	S obj	var	 	 	 	 
31	last.cel	2	S obj	var	 	 	 	 
32	current.cel	2	S obj	var	 	 	 	 
33	current.loop	2	S obj	var	 	 	 	 
34	current.view	2	S obj	var	 	 	 	 
35	number.of.loops	2	S obj	var	 	 	 	 
36	set.priority	2	S obj	num	 	 	 	 
37	set.priority.v	2	S obj	var	 	 	 	 
38	release.priority	1	S obj	 	 	 	 	 
39	get.priority	2	S obj	var	 	 	 	 
3A	stop.update	1	S obj	 	 	 	 	 
3B	start.update	1	S obj	 	 	 	 	 
3C	force.update	1	S obj	 	 	 	 	 
3D	ignore.horizon	1	S obj	 	 	 	 	 
3E	observe.horizon	1	S obj	 	string	 	 	 
3F	set.horizon	1	num	string	 	 	 	 
40	object.on.water	1	S obj	 	string	 	 	 
41	object.on.land	1	S obj	 	string	 	 	 
42	object.on.anything	1	S obj	 	string	 	 	 
43	ignore.objs	1	S obj	 	 	string	 	 
44	observe.objs	1	S obj	 	 	string	 	 
45	distance	3	S obj	S obj	var	 	 	 
46	stop.cycling	1	S obj	 	 	 	 	 
47	start.cycling	1	S obj	 	 	 	 	 
48	normal.cycle	1	S obj	 	 	 	 	 
49	end.of.loop	2	S obj	flag	 	 	 	 
4A	reverse.cycle	1	S obj	 	 	 	 	 
4B	reverse.loop	2	S obj	flag	 	 	 	 
4C	cycle.time	2	S obj	var	 	 	 	 
4D	stop.motion	1	S obj	 	 	 	 	 
4E	start.motion	1	S obj	 	 	 	 	 
4F	step.size	2	S obj	var	 	 	 	 
50	step.time	2	S obj	var	 	 	 	 
51	move.obj	5	S obj	num	num	num	flag	 
52	move.obj.v	5	S obj	var	var	num	flag	 
53	follow.ego	3	S obj	num	flag	 	 	 
54	wander	1	S obj	 	 	 	 	 
55	normal.motion	1	S obj	 	 	 	 	 
56	set.dir	2	S obj	var	 	 	 	 
57	get.dir	2	S obj	var	 	 	 	 
58	ignore.blocks	1	S obj	 	 	 	 	 
59	observe.blocks	1	S obj	 	 	 	 	 
5A	block	4	num	num	num	num	 	 
5B	unblock	0	 	 	 	 	 	 
5C	get	1	I obj	 	 	 	 	 
5D	get.v	1	var	 	 	 	 	 
5E	drop	1	I obj	 	 	 	 	 
5F	put	2	I obj	var	 	 	 	 
60	put.v	2	var	var	 	 	 	 
61	get.room.v	2	var	var	 	 	 	 
62	load.sound	1	num	 	 	 	 	 
63	sound	2	num	flag	 	 	 	 
64	stop.sound	0	 	 	 	 	 	 
65	print	1	message	 	 	 	 	 
66	print.v	1	var	 	 	 	 	 
67	display	3	num	num	message	 	 	 
68	display.v	3	var	var	var	string	 	 
69	clear.lines	3	num	num	num	string	 	 
6A	text.screen	0	 	string	 	 	 	 
6B	graphics	0	 	string	 	 	 	 
6C	set.cursor.char	1	message	string	 	 	 	 
6D	set.text.attribute	2	num	num	string	 	 	 
6E	shake.screen	1	num	string	 	 	 	 
6F	configure.screen	3	num	num	num	string	 	 
70	status.line.on	0	 	string	 	 	 	 
71	status.line.off	0	 	string	 	 	 	 
72	set.string	2	string	message	string	 	 	 
73	get.string	5	string	message	num	num	num	 
74	word.to.string	2	word	string	 	 	 	 
75	parse	1	string	 	 	 	 	 
76	get.num	2	message	var	 	 	 	 
77	prevent.input	0	 	 	 	 	 	 
78	accept.input	0	 	 	 	 	 	 
79	set.key	3	num	num	cntrl	 	 	 
7A	add.to.pic	7	num	num	num	num	num	num
7B	add.to.pic.v	7	var	var	var	var	var	var
7C	status	0	 	 	 	 	 	 
7D	save.game	0	 	 	 	 	 	 
7E	restore.game	0	 	 	 	 	 	 
7F	init.disk	0	 	 	 	 	 	 
80	restart.game	0	 	 	 	 	 	 
81	show.obj	1	num	 	 	 	 	 
82	random	3	num	num	var	 	 	 
83	program.control	0	 	 	 	 	 	 
84	player.control	0	 	 	 	 	 	 
85	obj.status.v	1	var	 	 	 	 	 
86	quit	1	num	(0 args for 2.089)	 	 	 	 
87	show.mem	0	 	 	 	 	 	 
88	pause	0	 	 	 	 	 	 
89	echo.line	0	 	 	 	 	 	 
8A	cancel.line	0	 	 	 	 	 	 
8B	init.joy	0	 	 	 	 	 	 
8C	toggle.monitor	0	 	 	 	 	 	 
8D	version	0	 	 	 	 	 	 
8E	script.size	1	num	 	 	 	 	 
8F	set.game.id	1	message	 	 	 	 	 
90	log	1	message	 	 	 	 	 
91	set.scan.start	0	 	 	 	 	 	 
92	reset.scan.start	0	 	 	 	 	 	 
93	reposition.to	3	S obj	num	num	 	 	 
94	reposition.to.v	3	S obj	var	var	 	 	 
95	trace.on	0	 	 	 	 	 	 
96	trace.info	3	num	num	num	 	 	 
97	print.at	4	message	num	num	num	(3 args for versions before 2.400)	 
98	print.at.v	4	message	var	var	var	(3 args for versions before 2.400)	 
99	discard.view.v	1	var	 	 	 	 	 
9A	clear.text.rect	5	num	num	num	num	num	 
9B	set.upper.left	2	???	???	 	 	 	 
9C	set.menu	1	message	 	 	 	 	 
9D	set.menu.item	2	message	cntrl	 	 	 	 
9E	submit.menu	0	 	 	 	 	 	 
9F	enable.item	1	cntrl	 	 	 	 	 
A0	disable.item	1	cntrl	 	 	 	 	 
A1	menu.input	0	 	 	 	 	 	 
A2	show.obj.v	1	var	 	 	 	 	 
A3	open.dialogue	0	 	 	 	 	 	 
A4	close.dialogue	0	 	 	 	 	 	 
A5	mul.n	2	var	num	 	 	 	 
A6	mul.v	2	var	var	 	 	 	 
A7	div.n	2	var	num	 	 	 	 
A8	div.v	2	var	var	 	 	 	 
A9	close.window	0	 	 	 	 	 	 
AA	unknown170	1	???	 	 	 	 	 
AB	unknown171	0	 	 	 	 	 	 
AC	unknown172	0	 	 	 	 	 	 
AD	unknown173	0	 	 	 	 	 	 
AE	unknown174	1	???	 	 	 	 	 
AF	unknown175	1	???	 	 	 	 	 
B0	unknown176	0	(1 arg for AGI version 3.002.086)	 	 	 	 	 
B1	unknown177	1	???	 	 	 	 	 
B2	unknown178	0	 	 	 	 	 	 
B3	unknown179	4	???	???	???	???	 	 
B4	unknown180	2	???	???	 	 	 	 
B5	unknown181	0	 	 	 	 	 	  


4.4 Description of the LOGIC Commands
from AGDS docs*
Last updated: 4 December 1997
Retrived from the Internet Archive
 
* This is from the manual of AGDS (Adventure Game Development Toolkit) which contains a good deal of information about the AGI interpreter and its data formats. Translated from Russian by Vassili Bykov, vbykov@cam.org

 
I.2.6 THE LOGIC RESOURCE
One of the most complex resources. It contains interpreter commands and messages. In essence, it is the LOGIC resource that determines the plot of the game. It describes all possible interactions between the objects and the use of the resources, according to the game script.

Let us consider the interpreter commands in detail.

I.2.6.1 ARITHMETIC COMMANDS
Commands that operate on variables:

[The allowed range of variable values is not specified anywhere explicitly, however implicitly it seems to be 8 bit (0..255). --VB]

increment(n)

The value of the variable Var(n) is incremented by one, i.e. Var(n) = Var(n)+1. If the value is already 255, it is left unchanged.

decrement(n)

The value of the variable Var(n) is decremented by one, i.e. Var(n) = Var(n)-1. If the value is 0, it is left unchanged.

assign(n, m)

Variable Var(n) is assigned the value m, i.e. Var(n) = m

assignv(n, m)

Variable Var(n) is assigned the value of Var(m), i.e. Var(n) = Var(m).

addn(n, m)

The value of variable Var(n) is incremented by m, i.e. Var(n) = Var(n) + m.

addv(n, m)

The value of variable Var(n) is incremented by the value of Var(m), i.e. Var(n) = Var(n) + m.

[Now what happens in the above two commands on 8-bit overflow: does the result wrap over 0 or stays 255? I.e. is 250 + 10 == 4 or 250 + 10 == 255? --VB]

subn(n, m)

The value of Var(n) is decremented by M, i.e. Var(n) = Var(n) - m

subv(n, m)

The value of Var(n) is decremented by Var(m), i.e. Var(n) = Var(n) - Var(m).

[Again, what happens when the result must be negative: is 1 - 2 == 255 or 1 - 2 == 0? --VB]

lindirectn(n, m)

Variable Var(i) where i is the value of Var(n) is assigned a value m, i.e. Var(Var(n)) = m.

lindirectv(n, m)

Variable Var(i) where i is the value of Var(n) is assigned the value of Var(m), i.e. Var(Var(n)) = Var(m).

rindirect(n, m)

Variable Var(n) is assigned the value of Var(i) where i is the value of Var(m), i.e. Var(n) = Var(Var(m)).

muln(n, m)

Variable Var(n) is multiplied by m, i.e. Var(n) = Var(n) * m.

mulv(n, m)

Variable Var(n) is multiplied by the value of Var(m), i.e. Var(n) = Var(n) * Var(m).

[What happens on overflow? --VB]

divn(n, m)

Variable Var(n) is divided by m, i.e. Var(n) = Var(n) / m.

divv(n, m)

Variable Var(n) is divided by the value of Var(m), i.e. Var(n) = Var(n) / Var(m).

[What happens on division by 0? --VB]

random(n, m, k)

Variable Var(k) is assigned a random value in the range between n and m.

Now let us consider the commands changing flag values. Remember that a flag can only have a value 0 or 1.

set(n)

flag(n) is set to 1.

set.v(n)

flag(i), where i is the value of var (n), is set to 1. i.e. flag(var(n)) = 1.

reset(n)

flag(n) is set to 0.

reset.v(n)

flag(i), where i is the value of var (n), is set to 0, i.e. flag(var(n)) = 0.

toggle(n)

flag(n) toggles its value.

toggle.v(n)

flag(i), where i is the value of var (n), i.e. flag(var(n)), toggles is value.

 

I.2.6.2 COMMANDS TO LOAD AND UNLOAD RESOURCES
Commands in this chapter load (into the interpreter's memory) and unload (discard, thus freeing interpreter's memory) LOGIC, PICTURE, VIEW, and SOUND resources. Always remember that the internal memory of the interpreter is 64K. This restriction is rarely a problem, but do not forget about it.

When the internal memory is full, the program has to be broken into parts which are loaded and unloaded as the story unfolds in the given room, or PICTURE, VIEW, and SOUND resources have to be manipulated using the commands below.

Remember that when a resource is unloaded, all resources loaded after it ARE ALSO AUTOMATICALLY UNLOADED!

load.logic(n)

Load into memory the LOGIC resource number n, i.e. Logic(n)

load.logic.v(n)

Load into memory the LOGIC resource number i, where i is the value of Var(n), i.e. Logic(Var(n))

load.pic(n)

Loads into memory the PICTURE resource number i, where i is the value of Var(n), i.e. Picture(Var(n))

[This may be a mistake in the original: I would expect this command to be `load_pic_v', while `load_pic n' would load resource number n. --VB]

[load_pic_v may be a more appropriate name for it, but the name above is what they gave it. There is no equivalent command that takes a number rather than a variable. --LE]

load.view(n)

Loads into memory the VIEW resource number n, i.e. View(n).

load.view.v(n)

Loads into memory the VIEW resource number i, where i is the value of Var(n), i.e. View(Var(n))

load.sound(n)

Loads into memory the SOUND resource number n, i.e. Sound(n).

[Note that there is no load_sound_v listed. I wonder if this is a mistake or there really is no way to load a sound with indirection (unlikely, I think) --VB]

[There really is no way of loading a sound with indirection. The command doesn't exist. --LE]

discard.pic(n)

Unloads PICTURE resource number i where i is the value of Var(n).

discard.view(n)

Unload VIEW resource number n, i.e. View(n)

discard.view.v(n)

Unloads VIEW resource number i where i the value of Var(n), i.e. View(Var(n)).

[And what about discard_logic, discard_logic_v, discard_sound, and discard_sound_v? --VB]

[There must be some other way that those commands are removed from memory, because the commands you mention above don't exist. --LE]

 

I.2.6.3 PROGRAM CONTROL COMMANDS
new.room command is one of the most powerful commands of the interpreter.

It is used to change algorithms of the object behaviour, props, etc. Automatic change of EGO coordinates imitates moving into a room adjacent to the edge of the initial one. [Sounds awkward but that's what it says. --VB]

The format of the command:

new.room(n)
new.room.v(n)

These commands do the following:

Commands stop_update and unanimate are issued to all objects;
All resources except Logic(0) are discarded;
Command player_control is issued;
unblock command is issued;
`set_horizon 36' command is issued;
Var(1) is assigned the value of Var(0);
Var(0) is assigned n (or the value of Var(n)
when the command is new_room_v);
Var(4) is assigned 0;
Var(5) is assigned 0;
Var(16) is assigned the ID number of the VIEW resource that was
associated with EGO (the player character).
Logic(i) resource is loaded where i is the value of Var(0) !
Set EGO coordinates according to Var(2):
- if EGO touched the bottom edge, put it on the horizon;
- if EGO touched the top edge, put it on the bottom edge of the screen;
- if EGO touched the right edge, put it at the left and vice versa.
Var(2) is assigned 0 (meaning EGO has not touched any edges).
Flag(5) is set to 1 (meaning in the first interpreter cycle after the new_room command all initialization parts of all logics loaded and called from the initialization part of the new room's logic will be called. In the subsequent cycle Flag(5) is reset to 0 (see Interpreter Work Cycle and the source of "Thunderstorm" program). THIS IS VERY IMPORTANT!).
Clear keyboard input buffer and return to the main AGI loop.
 

Subroutine call commands:

call(n)
call.v(n)

LOGIC resource number n (or number i where i the value of Var(n)) is executed as a subroutine. If the logic with the given ID is not loaded in memory, it is temporarily loaded and discarded after returning from the call (this takes extra time). call command does not change any variables or flags.

return

This command returns control to the interpreter if it is executed in Logic(0), or to the command following the call command which called the current logic.

jump <label>

This command unconditionally transfers control to a command starting with a symbol combination <label> within the same logic.

set.scan.start
reset.scan.start

Normally, when a logic is called using call command, execution begins at the first instruction. set_scan_start command sets the entry point at the command following it, while reset_scan_start returns entry point to the beginning.

 

I.2.6.4 OBJECT CONTROL COMMANDS
Interpreter controls movement of objects around the screen automatically checking the following conditions:

- If an object priority is 0 it cannot cross an unconditional barrier (pixels with priority 0).

- If an object priority is 15 and a command ignore_block has not been given to it, it cannot cross a conditional barrier (pixels with priority 1) and leave the block set using the `block' command.

- If an object has not been given `ignore.horizon' command, it cannot move above the horizon set using the set_horizon command.

- An object should follow the conditions set using object.on.water and object.on.land commands (see below).

Object number 0 is called EGO. It is different from others in that the player may move it around using the keyboard.

 

I.2.6.4.1 OBJECT DESCRIPTION COMMANDS
animate.obj(n)

Object number n is included in the list of object controlled by the interpreter.

OBJECTS NOT INCLUDED IN THAT LIST ARE CONSIDERED INEXISTENT!

unanimate.all

All objects are removed from the control list and are considered inexistent.

set.view(n, m)
set.view.v(n, m)

Object n is associated with a VIEW resource number m (or pointed to by Var(m)), which may be an image of the object.

set.loop(n, m)
set.loop.v(n, m)

Chooses a loop m (or Var(m)) in the VIEW resource associated with the object n.

fix.loop(n)

Turns off automatic choice of loop number for the object number n.

release.loop(n)

Turns on automatic choice of loop number depending on the direction of motion of the object n.

                      1
                8     |     2
                  \   |   /
                    \ | /
              7 ------------- 3      0 - object stands still
                    / | \
                  /   |   \
                6     |     4
                      5
Automatic choice of the loop is done according to the table:

- for objects with fewer than 4 but more than 1 loops:

Direction	still(0)	1	2	3	4	5	6	7	8
Loop	*	*	0	0	0	*	1	1	1
* - means the current loop number is retained

- for objects with more than 4 loops:

Direction	still(0)	1	2	3	4	5	6	7	8
Loop	*	3	0	0	0	2	1	1	1
 

set.cel(n, m)
set.cel.v(n,m)

Selects a cel m in the current loop of the object m.

last.cel(n, m)

The number of the last cel of the current loop of the object n is stored in Var(m).

current.cel(n, m)

The number of the current cel of the object n is stored in Var(m).

current.loop(n, m)

The number of the current loop of the object n is stored in Var(m).

current.view(n, m)

The number of the current VIEW resource associated with the object n is stored in Var(m).

set.priority(n, m)
set.priority.v(n,m)

Set priority of the view of the object n to m (or Var(m)).

release.priority(n)

Turns on the automatic priority choice for the object n. The priority is set depending on the vertical coordinate of the object.

<	y	<	priority
0	 	48	4
48	 	60	5
60	 	72	6
72	 	84	7
84	 	96	8
96	 	108	9
108	 	120	10
120	 	132	11
132	 	144	12
144	 	156	13
156	 	168	14
This way, as an object moves down it approaches the viewer.

get.priority(n, m)

The value of the current priority of the object n is stored in Var(m).

position(n, x, y)
position.v(n, x, y)

Coordinates of the object n, not yet displayed on the screen, are set to x and y (or Var(x) and Var(y)).

draw(n)

Object n is shown on the screen. The image uses the values of the loop and the cel in the VIEW resource associated with the object n (see set_view), as well as the priority and coordinates of the object. If a command start_cycling is also issued, an infinite "movie" for the object n is shown until stopped (for example, with stop_cycling).

erase(n)

Object n is erased from the screen.

get.posn(n, x, y)

Coordinates of the object n are stored in Var(x) and Var(y). Coordinates of the object are coordinates of the base point (bottom left corner) of cels of the VIEW resource associated with
the object.

Interpreter automatically shows a "movie" (a loop in the VIEW resource) associated with the object, starting at the specified cel. The following commands control this process.

start.cycling(n)

Enables automatic change of cels in a chosen (using set_loop) loop of a VIEW resource associated with the object n (using set_view).

stop.cycling(n)

Disables automatic change of cels in a chosen (using set_loop_ loop of a VIEW resource associated with the object n (using set_view).

normal.cycle(n)

Cels of the loop associated with the object n follow in a normal order:

0, 1, 2, .., k-1, 0, 1, 2..

reverse.cycle(n)

Cels of the loop associated with the object n follow in a reverse order:

k-1, k-2, ..., 1, 0, k-1, k-2, ..1, 0, ..

end.of.loop(n, m)

Plays the loop associated with the object n once, from the current cel to the last. When finished, Flag(m) is set to 1.

reverse.loop(n, m)

Plays the loop associated with the object n once in a reverse order, from the current cel to the first. When finished, Flag(m) is set to 1.

cycle.time(n, m)

Var(m) sets the time in interpreter cycles between cel changes for the object n. When Var(m) = 1 cels are changed every cycle.

 

I.2.6.4.2 OBJECT MOTION CONTROL COMMANDS
The following commands can be given to the object included in the interpreter control list with animate_obj:

set.horizon(n)

Set the horizon to y = n.

ignore.horizon(n)

Object n moves regardless of the horizon position.

observe.horizon(n)

Object n cannot move above the horizon.

block(x1, y1, x2, y2)

Sets a rectangular area (block).

(x1, y1)
   ------------------
   |                |
   |                |
   |                |
   ------------------
                  (x2, y2)
unblock

Cancels previously set block.

ignore.blocks(n)

Object n moves ignoring conditional barriers (pixels with priority 1) and a block set with a block command.

observe.blocks(n)

Object n may not cross conditional barriers or leave the block.

ignore.objs(n)

Object n moves regardless of positions of other objects.

observe.objs(n)

Object n treats other objects as obstacles.

player.control

The player is allowed to control EGO (object number 0) using the keyboard or the joystick.

program.control

The player is not allowed to control object 0 (EGO).

stop.motion(n)

Motion of object n is stopped. If n = 0, program_control is automatically executed.

start.motion(n)

Motion of object n is started. If n = 0 (EGO), player_control automatically executed.

step.size(n, m)

Var(n) determines the number of pixels the object n moves each step.

step.time(n, m)

Var(n) determines the speed of object n motion: delay in the interpreter cycles between consecutive steps. If Var(m) = 1, step occurs on every cycle.

move.obj(n, x, y, s, m)
move.obj.v(n, x, y, s, m

Object n is told to move to the point x,y (or Var(x), Var(y)) by s pixels every step. When the destination is reached, Flag(m) is set to 1. If n = 0 (EGO), program_control is executed automatically.

follow.ego(n, s, m)

Object n is told to chase object 0 (EGO) by s pixels every step. When EGO's and the object's coordinates become equal, Flag(m) is set to 1.

wander(n)

Object n randomly changes the direction of its motion (wanders). If n = 0 (EGO), program_control is issued automatically.

normal.motion(n)

Special object motion mode is canceled. The object continues to move in the direction it was moving in at the time the command was issued.

set.dir(n, m)

Object n is told to move in the direction Var(m)

                      1
                8     |     2
                  \   |   /
                    \ | /
              7 ------------- 3      0 - stop
                    / | \
                  /   |   \
                6     |     4
                      5
get.dir(n, m)

Direction of object n motion is stored in Var(m).

object.on.water(n)

Object n is allowed to be only in the area where its base line is completely on pixels with priority 3 (water surface).

object.on.land(n)

Object n is not allowed to touch pixels of water surface (priority 3).

object.on.anything(n)

Motion restrictions previously set on the object n with commands object_on_water or object_on_land are cancelled.

reposition(n, dx, dy)

Object n jumps from its current location into the location with coordinates x + Var(dx), y + Var(dy).

[Shouldn't there be reposition and reposition.v? --VB]

[There should be, but they don't exist. --LE]

reposition.to(n, x, y)
reposition.to.v(n, x, y)

Similar to the preceding command, but the object is moved to the point x, y (Var(x),Var(y)).

stop.update(n)

Object n is removed from the list of objects updated by the interpreter on each step. The object stays on the screen unchanged.

start.update(n)

Object n is redrawn on each interpreter step.

force.update(n)

Object n is redrawn immediately, without waiting for the end of the interpreter cycle.

distance(n, m, d)

If both objects n and m are on the screen, then

Var(d) = ABS(x(n) - x(m)) + ABS(y(n) - y(m)),

otherwise Var(d) = 255.

 

I.2.6.4.3 INVENTORY ITEM MANAGEMENT COMMANDS
OBJECT resources, stored in a separate file OBJECT, are most often used to represent inventory items. An item is a structure which consists of a one-byte field called room and a string of text, the item name.

If the room field of an item is 255, the item belongs to the player. Otherwise the item is considered to be in the room with the corresponding ID number.

Let us consider item management commands.

get(n)
get.v(n)

Stores 255 in room field of an object n, which means the player owns it.

drop(n)

Stores 0 in the room field of object n.

put(n, m)

put.v(n, m)

Stores the value m (or Var(m)) in the room field of the object n.

get.room.v(n, m)

Stores the value of the room field of object Var(n) in Var(m).

status

The screen is switched to text mode; the top line displays "You are carrying:", then the names of the object with room field equal to 255 are listed. If there are no such objects, the word "nothing" is displayed.

If Flag(13) = 1 (allow item selection), a highlight appears which allows the player to select an item name. When Enter is pressed, the selected object number is stored in Var(25). When Esc is pressed, 255 is stored in Var(25).

 

I.2.6.5 PICTURE RESOURCE MANAGEMENT COMMANDS
The following commands operate on PICTURE resources (3D props), prepared using PM editor and loaded in the interpreter memory using load_pic:

draw.pic(n)

A PICTURE resource number i, where i is the value of Var(n) is executed. As the result, the background picture is created in the internal buffer of the interpreter. Before execution, the buffer is cleared, i.e. all pixels are set to colour 15 and priority 4.

overlay.pic(n)

Just like the above, only the internal buffer is not cleared before drawing. Picture(Var(n)) is drawn over the existing picture.

add.to.pic(a, b, c, d, e, f, g)
add.to.pic.v(a, b, c, d, e, f, g)

A picture of a VIEW resource is added to the background as its component. Typically, this is used to add small complicated details which would require too many PICTURE resource commands to draw.

Parameters are:

a ( Var(a) ) - number of the VIEW resource;
b ( Var(b) ) - loop number;
c ( Var(c) ) - cel number;
d ( Var(d) ) - x coordinate;
e ( Var(e) ) - y coordinate;
f ( Var(f) ) - priority;
g ( Var(g) ) - margin.

If margin is 0, 1, 2, or 3, the base of the cel is surrounded with a rectangle of the corresponding priority. If margin > 4, this extra margin is not shown.

show.pic

Shows internal buffer on the screen.

ATTENTION!

Please use the following sequence of commands when loading PICTURE resources
in the interpreter memory:

load.pic(n);
draw.pic(n);
discard.pic(n);
.............
show.pic;

Any other order may crash the interpreter without any diagnostic messages.

 

I.2.6.6 SOUND RESOURCE MANAGEMENT COMMANDS
sound(n, m)

Starts playback of the SOUND resource number n. When finished, Flag(m) is set to 1.

stop.sound

Stops the playback.

 

I.2.6.7 TEXT MANAGEMENT COMMANDS
prevent.input

Prevents the user from entering anything using the keyboard.

accept.input

Allows the user to enter text using the keyboard.

print(n)
print.v(n)

Opens a text window in the centre of the screen, where a message number n (or Var(n)) from the messages field of the current LOGIC resource is displayed. Output mode is determined by Flag(15) (see flag description)

The message is a NULL-terminated string of text. In addition to letters, digits, and other symbols, the string may contain:

- Newline character (0Ah);
- Format element:

%v<decimal number> - at this place the output will include a decimal value of variable with the given number.
%m <number> - the text of the message with the given number is inserted at this place.
%0 <number> - the name of the item with the given number is inserted at this place.
%w <number> - a vocabulary word with the given number is inserted at this place.
%s <number> - a string variable with the given number is inserted at this place.
%g <number> - a message with this number from message field of Logic(0) is inserted at this place.
For v format, you can add a vertical line and a number of characters the output should take. In this case leading zeros are not suppressed in the output.

Example: %v34 | 2

When you write your messages, remember that the interpreter wraps
the text between the lines as needed when the message is displayed.

display(R<ow>, C<olumn>, N<umber>)
display.v(R<ow>, C<olumn>, N<umber>)

Prints a message number N (Var(N)) in the row R (Var(R)), starting with the column C (Var(C)). No window is created, so it is up to the programmer to erase the output when it is no longer needed.

print.at(n, x, y, l)
print.at.v(n, x, y, l)

Analogous to print but the programmer can specify the window location. x, y, and l are constants specifying coordinates of the top left corner of the window and its width in character cells of a 40x25 screen.

version

Prints interpreter version in the centre of the screen.

text.screen

The screen switches to the text mode 40x25.

graphics

The screen returns to the graphics mode. The picture on the screen is restored.

set.cursor.char(n)

First byte of the message n is user as a text mode cursor.

set.text.attribute(F<oreground>, B<ackground>)

Sets foreground and background colours for display, get_num, and get_string commands.

clear.lines(n, m, C<olor>)

Clears text lines from n to m using colour C.

clear.text.rect(x1, y1, x2, y2, C<olor>)

Clears a rectangular area with top left corner coordinates (x1,y1) and bottom right coordinates (x2,y2) using colour C.

status.line.on

Shows the status line containing the current score and sound status (on/off).

status.line.off

Removes the status line.

 

I.2.6.8 STRING MANAGEMENT COMMANDS
set.string(n, m)

Stores message number m in the string variable n.

word.to.string(n, m)

Word number m of the user input is stored in String(n).

get.string(n, m, x, y, l)

User input is stored in String(n). m is the number of the message used as the prompt, x, y, l are input position and maximum string length.

parse(n)

Parses String(n) as if it were entered by the player.

get.num(n, m)

Enters a number from the keyboard into Var(m). Message n is used as the prompt.

 

I.2.6.9 INITIALIZATION COMMANDS
set.key(s, c)

Set interpreter's special key.

c - code (decimal number from 0 to 255);

s - if the key is a regular, or Ctrl+key pair,
the ASCII code (for example, 0009h - TAB);

- if the key is functional or Alt+key pair,
the corresponding scan-code in the high byte of s.
For example, the scan code of F1 is 3b00h, Alt+Z - 2c00h, etc.

set.game.id(n)

Message n is scanned by the interpreter and compared with its internal identifier. On mismatch, the program exits. For AGDS interpreter the identifier is 'TQ'.

script.size(n)

Sets the size of script table in bytes. Script table stores codes of some interpreter commands. It is needed to the interpreter can correctly reload resources when restore_game is executed.

trace.info(n, m, l)

Sets the built-in debugger parameters

n - number of LOGIC resource with command names.
m, l - first line and height of the debugger window.

trace.on

Turns on the debugger. In general, the debugger is turned on with Scroll Lock key when the command name table is loaded even if this command does not occur in the program.

log(n)

This is a debugging command. It writes a log message in a file:

Room <current room> Input line <current input line>
followed by the message number n.

 

I.2.6.10 MENU MANAGEMENT COMMANDS
Creating your program, you can offer the player a choice using a system of menus. These may be short one-line questions (menu header) with several answers (menu elements), or a prompt to change some of the system parameters, for example, object movement speed. Let us consider these commands.

set.menu(n)

Message n is used as the header of the menu elements which follow.

set.menu.item(n, c)

Message n is used as a menu element, where c is this element's code (a number between 0 and 255).

submit.menu

Ends menu creation.

enable.item(c)
disable.item(c)

Enables or disables a menu item with the code c.

                              |-------- heading
                              v
                          -------------------------------
                          | Fill                        |
                          -------------------------------
               Menu   --->| Save       |
               Element    |------------|
                          | Restore    |
                          |------------|
                          |XXXXXXXXXXXX|<---- menu element disabled
                          |------------|      using disable.item
                          | Quit       |
                          --------------      
menu.input

If Flag(14) = 1, a menu system is shown on the screen, allowing the user to choose an item. Whether an item with the code c has been chosen can be tested using a command 'controller c', where c is the code assigned to the menu item.

 

I.2.6.11 LOGICAL COMMANDS
Apparently, to build a program you need commands that change the execution order of instructions. To check for various conditions, test commands are used.

I.2.6.11.1 TEST COMMANDS
The result of test command can be either TRUE or FALSE.

equaln(n,m)

True if Var(n) = m.

equalv(n, m)

true if Var(n) = Var(m).

lessn(n,m)

True if Var(n) < m.

lessv(n, m)

True if Var(n) < Var(m).

greatern(n, m)

True if Var(n) > m.

greaterv(n, m)

True if Var(n) > Var(m).

isset(n)

True if Flag(n) = 1 (set).

isset.v(n)

True if Flag(Var(n)) = 1 (set).

has(n)

True if the room field of item n is 255, i.e. the item belongs to the player.

obj.in.room(n, m)

True if room field of the object n is Var(m).

posn(n, x1, y1, x2, y2)

True if the coordinates of the base point of the cel which is the current image of object n satisfies the equation
x1 <= x <= x2, y1 <= y <= y2.

obj.in.box(n, x1, y1, x2, y2)

True if the base of the object n is completely within the rectangle specified using its top left (x1,y1) and bottom right (x2,y2) corners.

(x1, y1)
   ------------------
   |                |
   |                |
   |                |
   ------------------
                  (x2, y2)
center.position(n, x1, y1, x2, y2)

True of the center of the base line of the object n is inside the rectangle specified as its top left and bottom right corners.

right.position(n, x1, y1, x2, y2)

True of the right side of the base line of the object n is inside the rectangle specified as its top left and bottom right corners.

have.key

True if the user has pressed any key on the keyboard. Used to create cycles to wait until any key is pressed.

compare.strings(s1, s2)

True if string(s1) = string(s2).

said(n, W(i)) , where i = 1, ..., n

True if the player has entered a phrase that completely matches W(1),...W(n), where n is the number of W(i) which are codes of the vocabulary words.

Here is how the input is matched. After the player types a message and presses Enter, the input line is processed by the interpreter.

Interpreter removes all punctuation marks.
All characters are converted to lowercase.
All sequences of more than one space are replaced with a single space.
Starting with the first word of the input, the interpreter looks up the vocabulary, trying to find the longest character sequence matching the entered.
If the search is unsuccessful, Var(9) is assigned the number of
the word in the message that failed to match and the processing
ends. If all the words have been assigned some codes:

The Interpreter removes from the sequence of codes all zeros (that means all vocabulary words with zero codes are ignored).
Flag(2) (the user has entered an input line) is set to 1
Flag(4) (`said' command accepted the user input) is set to 0.
If the sequence of code produced by the interpreter is

V(1), V(2),...V(m).

The test is performed as follows:

If Flag(2) = 0 or Flag(4) = 1, return FALSE.

Compare parameters W(i) and codes V(i) as follows:

if W(i) = 1, it matches any V(i);
if W(i) = 9999, it matches the whole remaining input i.e. the codes V(i), V(i+1),...V(m).
Otherwise W(i) should be equal to V(i).

If all elements match, Flag(4) (`said' accepted the user input) is set to
1 and the command returns TRUE. Otherwise, FALSE is returned.

controller(n)

True if the event with code n has occurred:

a key with the code n was pressed (set using set_key);
menu item with code n was selected in command menu_input.
 

I.2.6.11.2 GENERAL FORMAT OF A LOGICAL COMMAND
The interpreter allows to work with logical expressions using a logical command. Its general format is the following:

                 if_
                   logical expression   ; is the result true?
                 else_  LABEL           ;  no: go to LABEL
                                        ; yes: execute commands
                   ................     ;     between else_
                                        ;     and LABEL
          LABEL: ..................
                 ..................
Logical expressions are allowed only within a logical command and are sequences of tests and operations between if_ and else_ tokens. An expression is true if all its elements are true.

The following operations are allowed, listed in the order of decreasing priority:

logical negation (not_, works on the expression that follows);
conjunction. It is performed by default on a sequence of test
commands in a logical expression.
disjunction. It is performed on the group of test commands beginning
and ending with or_ token. Therefore, we may call or_ a disjunctive
bracket.
If a logical expression is true, the commands following the expression are executed; if false, the program branches to the instruction labeled LABEL.

Here are a few examples of the use of logical commands and calculating logical expressions.

Example 1

        assignn 35, 10  ; v35 = 10
        set     24      ; f24 -> 1

        if_             ; if
          equaln 35, 10 ;   v35 = 10 and (conjunction by default)
          isset  24     ;   f24 set to 1 ?
        else_ A         ; no: go to A
                        ;   yes:
          sound 25, 52  ;   play sound 25, when finished f52 -> 1
          return        ;   return control

     A: sound 30, 52    ; play sound 30, when finished f52 -> 1
        ............
Here the test commands are by default combined with AND operation, and the
result is TRUE. Therefore, sound 25 will play and control will return to
the interpreter (if we are in Logic(0), or to the command following the
subroutine call (call or call_v) in the caller logic.

Example 2.

        assignn 35, 40  ; v35 = 10
        set     24      ; f24 -> 1

        if_             ; if
          equaln 35, 40 ;   v35 = 10 and (conjunction by default)
          not_          ;   not
          isset 24      ;   set (equals to 1) f24 ?
        else_ A         ; no: go to A
                        ;   yes:
          sound 25, 52  ;   play sound 25, when finished f52 -> 1
          return        ;   return control

     A: sound 30, 52    ; play sound 30, when finished f52 -> 1
        ............
Let us consider how this fragment works. The result of "test equaln 35, 40" is TRUE, sequence "not_ isset 24" (negation first) is FALSE and the result of conjunction is FALSE, which will play sound 30.

Example 3.

        assignn 25, 10  ; v35 = 10
        set     24      ; f24 -> 1
        reset   25      ; f25 -> 0

        if_             ; if
          isset  24     ;   f24 set to 1 and (conjunction by default
          or_           ;   open disjunctive bracket
            greatern 25, 11  ; if v25 > 11
            not_             ; and not
            isset    25      ; set (equals 1) f25
          or_           ;   close disjunctive bracket
                        ; is TRUE ?
        else_ A         ; no: go to A
                        ;   yes:
          sound 25, 52  ;   play sound 25, when finished f52 -> 1
          return        ;   return control

     A: sound 30, 52    ; play sound 30, when finished f52 -> 1
        ............
In the result of this fragment execution, sound 25 will play because "greatern 25, 11" is FALSE, "not_ isset 25" is TRUE, disjunction of these is TRUE and (default) conjunction of them is - TRUE.

If, after reading this section, not everything is clear, see the source code of the educational program "Thunderstorm" and analyze them yourself.

 

I.2.6.12 OTHER COMMANDS
configure.screen(a, b, c)

Sets position of lines on the screen:
a = 1 (minimum line number for print);
b - user input line;
c - status line.

obj.status.v(n)

Prints a message for the object Var (n):

Obj <number> x: <coordinate> y: <coordinate> pri: <priority>
stepsize: <step size>.

show.mem

Displays a report of the interpreter memory status.

show.pri.screen

Shows priorities of the screen pixels. Priority n is shown as color number n (see color setting commands in I.1.2.1.1).

show.obj(n)

In the centre at the bottom of the screen a cel 0 of loop 0 of the VIEW resource n is shown. In the centre of the screen, a message associated with the VIEW resource is printed.

[That's what they say but I suspect they mean OBJECT n, not VIEW resource. --VB]

[Actually, in this case the argument does refer to the VIEW resource. This is because the VIEW in question isn't meant to be a controlled object but instead is simply the picture and textual description of the an inventory item. --LE]

shake.screen(n)

The screen shakes n times.

echo.line

The last line entered by the user is displayed in the input line.

cancel.line

Input line is cleared.

close.window

If there is a text window on the screen, it is removed.

open.dialogue
close.dialogue

Enables and disables get_string and get_num commands if prevent_input has been issued.

restart.game

Restarts the game from the very beginning.

save.game
restore.game

These command save and restore the current state of the game into disk files.

pause

Stops the interpreter until any key is pressed.

quit(n)

Exits the interpreter.

If n = 1, quits immediately
If n = 0, asks "Press ENTER to quit.", "Press ESC to continue."

init.joy

Initialize joystick.

toggle.monitor

Switch RGB monitor into the graphics mode.

upper.left

Usually the crossing by an object of various areas and lines is tracked by the base point (bottom right corner) of its cel. After this command, top left corner is used as such a point.

4.5 Discussion of Sample LOGIC Code from KQ4
Last updated: 31 August 1997
Retrived from the Internet Archive
 
Kings Quest IV: Room 7
Some of you may know that "The Official Book of King's Quest" included three small fragments of AGI code for ROOM 7 in the AGI version of KQ4. These fragments are given below along with the same fragments taken from the game itself. There are a few differences which is to be expected but generally the code is very similar. These examples show how the coder wrote the code and what it now looks like in the final product. I've included a few comments where some interesting observations can be seen.

Animating the smoke
FROM THE BOOK

 animate.obj( smoke);
 ignore.horizon( smoke);
 set.view( smoke, v.fish.cabin);
 set.loop( smoke, 1);
 ignore.blocks( smoke);
 position( smoke, 95, 16);
 work = 3;
 step.time( smoke, work);
 cycle.time( smoke, work);
 draw( smoke);
FROM THE GAME

 animate.obj(7);
 ignore.horizon(7);
 set.view(7, 114);
 set.loop(7, 1);
 ignore.objs(7);                [ These two lines have been added.
 set.priority(7, 5);            [
 ignore.blocks(7);
 position(7, 95, 16);
 assignn(152, 3);               [ Equivalent to 'work = 3;'
 step.time(7, 152);
 cycle.time(7, 152);
 draw(7);
COMMENTS

Opening the door
FROM THE BOOK

if (said( open, door)) {     [ must be close enough
  if (posn( ego, 86, 120, 106, 133)) {
    if (!night) {
      if ( door.open) {
        print("The door is already open. . .
      }
      else {
        set( game.control);
        set.priority( ego, 11);
        start.update( door);
        end.of.loop( door, door.done);
      }
    }
    else {
      print("You can't -- it's locked...
    }
  }
  else {
    set( notCloseEnough);
  }
}
FROM THE GAME

if (said(OPEN, DOOR||DOORS||DOORWAY||DOORWAYS)) { 
  if (posn(0, 86, 120, 106, 133)) { 
    if (!isset(38)) { 
      if (isset(231)) { 
        print("The door is already open.");  
      }
      else { 
        set(36);
        prevent.input();
        start.update(5);
        assignn(152, 3);
        cycle.time(5, 152);
        end.of.loop(5, 232);
        sound(70, 154);
      }
    }           
    else { 
      print("You can't.  It's locked and you 
             don't have the key.");
    }
  }
  else { 
    set(113);
  }
}
Unlocking the door
FROM THE BOOK

 if (said( unlock, door)) {     [must be close enough
   if (posn( ego, 86, 120, 106, 133)) {
     if (!night) {
       print("The door is already unlocked. . .
     }
     else {
       printf("You can't, it's locked. . .
     }
   }
   else {
     set( notCloseEnough);
   }
 }
FROM THE GAME

 if (said(UNLATCH||UNLOCK, DOOR||DOORS||DOORWAY||DOORWAYS)) { 
   if (posn(0, 86, 120, 106, 133)) { 
     if (!isset(38)) { 
       print("The door is already unlocked.");
     }
     else { 
       print("You can't.  It's locked and you 
              don't have the key.");
     }
   }
   else { 
     set(113);
   }
 }
Knocking on the door
FROM THE BOOK

 if ((said( knock, at, door) || said( knock) ||
      said( knock, on, door) || said( knock, door)) {
   if (posn( ego, 86, 120, 106, 133)) {
     if (!night) {
       print("You knock on the door. . .
              a woman says. . .
     }
     else {
       printf("You knock on the. . .
               a man calls out. . .
     }
   }
   else {
     set( notCloseEnough);
   }
 }
FROM THE BOOK

 if (said(BANG||KNOCK||RAP||TAP) ||
     said(BANG||KNOCK||RAP||TAP, DOOR||DOORS||DOORWAY||DOORWAYS)) { 
   if (posn(0, 86, 120, 106, 133)) { 
     if (!isset(38)) { 
       print("You assertively knock on the shanty 
              door.  A woman's voice answers, "Jest come on in!"");
     }
     else { 
       print("You assertively knock on the shanty 
              door.  From inside, a man's voice calls out, "D'ya know 
              what TIME it is?!  GO AWAY!!"");
     }
   }
   else { 
     set(113);
   }
 }
Fall rocks
FROM THE BOOK

 if (hit.special) {
   if ((rf2 || rf3 || rf4)) {
     reset(hit.special);
     get.posn(ego, priorx, priory);
     position.f(dude, priorx, priory);
     ignore.blocks(dude);
     set( game.control);
     set.view( dude, v.ego.land);
     if ((ego.dir == 3 || ego.dir == 4)) {
       set.loop( dude, 2);
     }
     else {
       set.loop( dude, 3);
     }
     fix.loop(dude);
     work = 3;
     step.size( dude, work);
     work = 3;
     cycle.time( dude, work);
     start.cycling(dude);
     erase(ego);
     draw(dude);
     if (rf3) {
       work6 = 0;
       move.obj.f( dude, tempx, tempy, work6, fall.done);
     }
     if (rf4) {
       work6 = 0;
       move.obj.f( dude, tempx, tempy, work6, fall.done);
     }
     if (rf2) {
       if (priory < 125) {
         set.priority( dude, 9);
         tempy=132;
         work6=0;
         move.obj.f( dude, ego,x, tempy, work6, fall.done);
       }
       else {
         set.priority(dude, 15);
         tempy = 156;
         work6 = 0;
         move.obj.f( dude, ego.x, tempy, work6, fall.done);
       }
     }
   }
 }
FROM THE GAME

 if (isset(3)) {     [ hit.special
   if (isset(222) || isset(223) || isset(224)) {     [ rf2, rf3, rf4
     reset(3);
     sound(51, 154);
     get.posn(0, 134, 135);
     position.v(12, 134, 135);
     ignore.blocks(12);
     set(36);
     prevent.input();
     set.view(12, 11);
     if (equaln(6, 3) || equaln(6, 4)) { 
       set.loop(12, 2);
     }
     else { 
       set.loop(12, 3);
     }  
     fix.loop(12);
     assignn(152, 3);
     step.size(12, 152);
     assignn(152, 3);
     cycle.time(12, 152);
     start.cycling(12);
     erase(0);
     draw(12);
     if (isset(223)) { 
       assignn(158, 0);
       move.obj.v(12, 107, 108, 158, 226);
     }
     if (isset(224)) {
       assignn(158, 0);
       move.obj.v(12, 107, 108, 158, 226);
       set.priority(12, 14);
     }
     if (isset(222)) { 
       if (lessn(135, 125)) { 
         set.priority(12, 9);
         assignn(108, 132);
         assignn(158, 0);
         move.obj.v(12, 33, 108, 158, 226);
       }
       else { 
         set.priority(12, 14);
         assignn(108, 158);
         assignn(158, 0);
         move.obj.v(12, 33, 108, 158, 226);
       }
     }
   }
 }
 
 5.1 PICTURE Resource Format
by Lance Ewing
Last updated: 5 December 1997
Retrived from the Internet Archive
 
Some of this first section has been taken from "The Official Book of King's Quest" written by Donald B. Trivette.

INTRODUCTION
The PICTURE is usually used for background pictures and other full screen images. Pictures in AGI and early SCI games are not stored as a complete picture. Instead they're constructed and stored as coordinates and vectors. Vectors give the instructions for drawing a picture and they have the advantage of taking less space than would a bit image of a complete picture.

PRIORITY BANDS
To maintain and enhance the three dimensional quality of the rooms, every object is constructed with a priority in relation to other objects. There are 16 bands or areas in which things may be placed. Although the priority bands are invisible in the finished product, the artist must use them like a horizontal grid as he draws the room. Considerable effort and time is spent placing houses, bushes, and trees so the player remains unaware of the rooms mathematical rigidity. It wouldn't so for things to look like they were lined up on a checker board.

In AGI games, the priority bands lie roughly in the following Y ranges:

Priority Band	Y range
4	-
5	48 - 59
6	60 - 71
7	72 - 83
8	84 - 95
9	96 - 107
10	108 - 119
11	120 - 131
12	132 - 143
13	144 - 155
14	156 - 167
15	168.
The reason that there is no priority 0 to 3 shown above is because they don't exist. Priority four has the least priority. It is given to the background components. Nothing is ever given a priority of four except for the background parts of the picture itself. The colours black, blue, green, and cyan are infact used for control lines because the control lines and the priority bands are drawn on the same screen for AGI games, and this means that there would be a clash if we had priority 0 to 3.

I've checked all the AGI games including those using version 3 and it looks as if nothing is ever drawn below 168. Some objects in the picture might have a priority of 15. These objects will start from a position with a Y component of 168. Ego can never walk below 167 and thus never has a priority of 15. SCI games are obviously a bit different because they extend the pictures down to the full 200 pixels.

CONTROL LINES
As the room nears completion, the artist adds control lines that determine where Ego can walk. Ego shouldn't walk through a wall or tree, for example, but sometimes Ego does. The Sierra staff spend a lot of time running Ego all over the rooms looking for places where Ego falls off or walks through something Ego shouldn't. Fixing an error may involve shifting things around or adding new features to a room to cover up a bug. I remember finding a bug in Space Quest 2 which allowed Roger to walk off into space in the starting room.

Black = unconditional barrier.
Blue = conditional barrier.
Green = alarm barrier.
Cyan = water (or any other surface).

Some of the above control lines set flags that can be tested when EGO walks over them (see flag descriptions in another document).

In most games, black and blue appear to be used for obstacle use which means that Ego can't walk past that line. This is the main use for control lines. Other uses include triggers which active an event. For example, control lines are used at the edge of water, or the edge of a cliff to tell the interpreter at what point it should execute its "drowning" or "falling" sequence of events. We can all remember the nasty trap that the hunter beast on Labion set for us in Space Quest II. This is activated when Ego walks past a green control line.

In some games like KQ1, KQ2, KQ3, and SQ1, you can press ALT-D to enter a Debug mode. In this mode you can switch to the screen which holds the priority bands and control lines. In KQ1 you push F6, in KQ2 F8, and in all the others you usually type "show priority".

CONTROL LINES AND PRIORITY INFORMATION
In the AGI interpreter, the priority bands and control lines are drawn on the same screen. This can lead to problems when the interpreter wants to know the priority of a pixel that has a control line drawn over it. The way that the interpreter deals with this is to search downwards until it finds a pixel that isn't a control line and it assumes that the pixel it is looking at is the same priority as the one it found by searching downwards (increasing Y). Usually this will be the pixel immediately below but for some pixels this can be as far away as twenty pixels or more!! In some games this can cause a noticeable visual error if you are aware of it. For example, you could walk behind a strip of grass that thinks it is part of the tree below it (KQ1, room 20, blue control line beside left hand tree). There are also a number of other one pixel visual errors that are virtually unnoticeable if you don't know they are there.

                             _
                            |_| <- priority required for this pixel.
      Search downwards  |   |_| \
      for next pixel    |   |_|  \___ These pixels have all got a control
      with a priority  \|/  |_|  /    line covering their priority info.
                            |_| /
                            |_| <- use this pixels priority.
It may be possible to draw the control lines on a separate screen altogether which would conserve the priority information.

 

THE FORMAT
Pictures are drawn using nine different drawing actions. These actions are given values from 0xF0 to 0xFA and are defined as follows:

0xF0 : Change picture colour and enable picture draw.
0xF1 : Disable picture draw.
0xF2 : Change priority colour and enable priority draw.
0xF3 : Disable priority draw.

0xF4 : Draw a Y corner.
0xF5 : Draw an X corner.
0xF6 : Absolute line (long lines).
0xF7 : Relative line (short lines).
0xF8 : Fill.
0xF9 : Change pen size and style.
0xFA : Plot with pen.

0xFB - 0xFE : Unused in most AGI games.

Note: SQ2 appears to be the only AGI version 2 game that uses 0xF9 and 0xFA. The AGI interpreters before this game will most likely not support these two drawing actions.

The special code 0xFF says that the end of the picture data has been reached. All other values are used by the various drawing actions to tell them what to draw and will always be less than 0xF0. The picture data can be processed byte by byte. Whenever a value of 0xF0 or greater is encountered, the action is changed to the one given and then all the bytes between this code and the next action code are arguments to this action. Half of the actions have a set number of arguments, the other half can have an unlimited number of arguments.

In the following detailed descriptions of each action, the word "picture" refers to the screen that is seen by the player when they play the AGI screen. The word "priority" refers to the screen that is held in memory and contains control information invisible to the player. As a picture is drawn, both screens are updated depending on whether drawing is enabled from each screen.

0xF0 : CHANGE PICTURE COLOUR AND ENABLE PICTURE DRAW
Function: Changes the current drawing colour for the picture screen to that given by the one and only argument, and enables subsequent actions to draw to the picture screen.

Example: F0 0D Changes picture screen drawing colour to light magenta and enables drawing to the picture screen.

0xF1 : DISABLE PICTURE DRAW
Function: Disables drawing to the picture screen. This is done whenever there is something which only needs to be drawn on the priority screen such as the control lines. There are no arguments for this action.

0xF2 : CHANGE PRIORITY COLOUR AND ENABLE PRIORITY DRAW
Function: Changes the current drawing colour for the priority screen to that given by the one and only argument, and enables subsequent actions to draw to the priority screen.

Example: F0 04 Changes priority screen drawing colour to red and enables drawing to the priority screen.

0xF3 : DISABLE PRIORITY DRAW
Function: Disables drawing to the priority screen. This is done whenever there is something which only needs to be drawn on the picture screen such as the finer details of the picture. There are no arguments for this action.

THE CORNER ACTION
I call the following two actions the corner actions because they do not draw diagonal lines at all but instead alternate from horizontal line to vertical line (or vice versa) giving rise to a series of right angled corners.

       _________     
      |         |    B__
      |         |_____  |
      |               |_|
      A
The above diagram shows the type of pattern created. If A were the starting coordinate, then it would be called a Y corner. This is because the Y or vertical component is changed first. If B were the starting coordinate, then it would be called an X corner. This is because the X or horizontal component is changed first.

0xF4 : DRAW A Y CORNER
Function: The first two arguments for this action are the coordinates of the starting position on the screen in the order x and then y. The remaining arguments are in the order y1, x1, y2, x2, ...

Note that the y component is the first to be changed and also note that this action does not necessarily end on either component, it just ends when the next byte of 0xF0 or above is encountered. A line is drawn after each byte is processed.

Example: F4 16 16 18 12 16 F?

 ($12, $16)     ($16, $16)
           E   S                  S = Start
           X   X                  E = End
           XXXXX                  X = normal piXel
 ($12, $18)     ($16, $18)
0xF5 : DRAW AN X CORNER
Function: The first two arguments for this action are the coordinates of the starting position on the screen in the order x and then y. The remaining arguments are in the order x1, y1, x2, y2, ...

Note that the x component is the first to be changed and also note that this action does not necessarily end on either component, it just ends when the next byte of 0xF0 or above is encountered. A line is drawn after each byte is processed.

Example: F5 16 16 18 12 16 F?

  ($16, $12)   ($18, $12)
            EXX
              X            S = Start
              X            E = End
              X            X = normal piXel
            SXX
  ($16, $16)   ($18, $16)
0xF6 : ABSOLUTE LINE
Function: Draws lines between points. The first two arguments are the starting coordinates. The remaining arguments are in groups of two which give the coordinates of the next location to draw a line to. There can be any number of arguments but there should always be an even number.

Example: F6 30 50 34 51 38 53 F?

This will draw a line from (48, 80) to (52, 81), and a line from (52, 81) to (56, 83).

0xF7 : RELATIVE LINE
Function: Draw short relative lines. By relative we mean that the data gives displacements which are relative from the current location. The first argument gives the standard starting coordinates. All the arguments which follow these first two are of the following format:

S	X disp	S	Y disp
7	6	5	4	3	2	1	0
This gives a displacement range of between -7 and +7 for both the X and the Y direction.

Example: F7 10 10 22 40 06 CC F?

S + S = Start X+++X X = End of each line + + = pixels in each line E + E = End + + + + Remember that CC = (x-4, y-4). ++ X

              S
               +              S = Start
                X+++X         X = End of each line
                    +         + = pixels in each line
                E   +         E = End
                 +  +
                  + +         Remember that CC = (x-4, y-4).
                   ++
                    X
0xF8 : FILL
Function: Flood fill from the locations given. Arguments are given in groups of two bytes which give the coordinates of the location to start the fill at. If picture drawing is enabled then it flood fills from that location on the picture screen to all pixels locations that it can reach which are white in colour. The boundary is given by any pixels which are not white.

If priority drawing is enabled, and picture drawing is not enabled, then it flood fills from that location on the priority screen to all pixels that it can reach which are red in colour. The boundary in this case is given by any pixels which are not red.

If both picture drawing and priority drawing are enabled, then a flood fill naturally enough takes place on both screens. In this case there is a difference in the way the fill takes place in the priority screen. The difference is that it not only looks for its own boundary, but also stops if it reaches a boundary that exists in the picture screen but does not necessarily exist in the priority screen.

BRUSH STYLE
Drawing actions 0xF9 and 0xFA deal with plotting patterns. Most drawing programs have options to change the size, and style of the pen or brush. The style covers different shapes and textures. AGI PICTURES provide these tools as well.

0xF9 : CHANGE PEN SIZE AND STYLE.
Function: Change the characteristics of the pattern plotted by drawing action 0xFA. If bit 5 is not set, then the pattern is a solid shape. If bit 5 is set, then the pattern is like a splatter. Bit 4 selects whether the brush is a circle or a rectangle. Bits 0-2 give the size of the shape which will be a value from 0 to 7. These characteristics appear to only affect drawing action 0xFA.

The default brush is a solid circle or rectangle of size 0, which should be used until an 0xF9 action is encountered.

           ___ ___ ___ ___ ___ ___ ___ ___
          | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |
          |___|___|___|___|___|___|___|___|
                    |   |       |___|___|
 0 = Solid _________|   |           |
 1 = Splatter           |           |______ Pen size
                        |
 0 = Circle ____________|
 1 = Rectangle
RECTANGLE SIZES

 X XX XXX XXXX XXXXX XXXXXX XXXXXXX XXXXXXXX         size+1
 0 X* XXX XXXX XXXXX XXXXXX XXXXXXX XXXXXXXX       _____________
   XX X*X XXXX XXXXX XXXXXX XXXXXXX XXXXXXXX      |             | 
   1  XXX XX*X XXXXX XXXXXX XXXXXXX XXXXXXXX      |             | 
      XXX XXXX XX*XX XXXXXX XXXXXXX XXXXXXXX      |             | 
       2  XXXX XXXXX XXX*XX XXXXXXX XXXXXXXX      |             | (size*2)+1
          XXXX XXXXX XXXXXX XXX*XXX XXXXXXXX      |             |
           3   XXXXX XXXXXX XXXXXXX XXXX*XXX      |             |
               XXXXX XXXXXX XXXXXXX XXXXXXXX      |             |
                 4   XXXXXX XXXXXXX XXXXXXXX      |             |
                     XXXXXX XXXXXXX XXXXXXXX      |             |
  WHERE                5    XXXXXXX XXXXXXXX      |_____________|
                            XXXXXXX XXXXXXXX
    X = agi pixels             6    XXXXXXXX         IN GENERAL
    * = coordinates given           XXXXXXXX
        for plot                       7
CIRCLE SIZES

 X XX  X   XX    X     XX     XXX      XX            size+1
 0 X* XXX  XX   XXX   XXXX   XXXXX    XXXX         _____________
   XX X*X XXXX XXXXX  XXXX   XXXXX   XXXXXX       |             | 
   1  XXX XX*X XXXXX  XXXX   XXXXX   XXXXXX       |             | 
       X  XXXX XX*XX XXXXXX XXXXXXX  XXXXXX       |             | 
       2   XX  XXXXX XXX*XX XXXXXXX XXXXXXXX      |             | (size*2)+1
           XX  XXXXX XXXXXX XXX*XXX XXXXXXXX      |             |
           3    XXX   XXXX  XXXXXXX XXXX*XXX      |             |
                 X    XXXX  XXXXXXX XXXXXXXX      |             |
                 4    XXXX   XXXXX  XXXXXXXX      |             |
                       XX    XXXXX   XXXXXX       |             |
  WHERE                5     XXXXX   XXXXXX       |_____________|
                              XXX    XXXXXX 
    X = agi pixels             6      XXXX           IN GENERAL
    * = coordinates given              XX   
        for plot                       7
To implement this you will need to store bitmaps for each of these of these circles.

0xFA : PLOT WITH PEN
Function: Plots points with the pen defined with drawing action 0xF9. If the pen style is set to solid, then the arguments are just a list of coordinates to be plotted. If the pen style is set to splatter brush (texture), then the arguments are in groups of three with the first argument giving the texture number and the other two giving the coordinates. The texture number determines in what way the pixels will splatter within the defined shape. Bits 1-7 seem to give the actual texture number. Bit 0 does not do anything. This means that there are 120 different pixel splatter bitmaps (values 0xF0 and above can not be used as they are treated as drawing actions). There is actually only 32 bytes of texture data which means that most of the splatter bitmaps overlap.

TEXTURE DATA
All of the data needed for the 128 texture patterns is included in the following 32 bytes (256 bits):

    0x20, 0x94, 0x02, 0x24, 0x90, 0x82, 0xa4, 0xa2,
    0x82, 0x09, 0x0a, 0x22, 0x12, 0x10, 0x42, 0x14,
    0x91, 0x4a, 0x91, 0x11, 0x08, 0x12, 0x25, 0x10,
    0x22, 0xa8, 0x14, 0x24, 0x00, 0x50, 0x24, 0x04
The only difference between each texture pattern is its starting position within this table. The following table gives the starting bit position in the above table for each texture pattern number given as the first argument of each pen plot:

    0x00, 0x18, 0x30, 0xc4, 0xdc, 0x65, 0xeb, 0x48,
    0x60, 0xbd, 0x89, 0x04, 0x0a, 0xf4, 0x7d, 0x6d,
    0x85, 0xb0, 0x8e, 0x95, 0x1f, 0x22, 0x0d, 0xdf,
    0x2a, 0x78, 0xd5, 0x73, 0x1c, 0xb4, 0x40, 0xa1,
    0xb9, 0x3c, 0xca, 0x58, 0x92, 0x34, 0xcc, 0xce,
    0xd7, 0x42, 0x90, 0x0f, 0x8b, 0x7f, 0x32, 0xed,
    0x5c, 0x9d, 0xc8, 0x99, 0xad, 0x4e, 0x56, 0xa6,
    0xf7, 0x68, 0xb7, 0x25, 0x82, 0x37, 0x3a, 0x51,
    0x69, 0x26, 0x38, 0x52, 0x9e, 0x9a, 0x4f, 0xa7,
    0x43, 0x10, 0x80, 0xee, 0x3d, 0x59, 0x35, 0xcf,
    0x79, 0x74, 0xb5, 0xa2, 0xb1, 0x96, 0x23, 0xe0,
    0xbe, 0x05, 0xf5, 0x6e, 0x19, 0xc5, 0x66, 0x49,
    0xf0, 0xd1, 0x54, 0xa9, 0x70, 0x4b, 0xa4, 0xe2,
    0xe6, 0xe5, 0xab, 0xe4, 0xd2, 0xaa, 0x4c, 0xe3,
    0x06, 0x6f, 0xc6, 0x4a, 0x75, 0xa3, 0x97, 0xe1
Important note: When drawing the brush, if the bit position in the texture data (first table above) reaches 255, it should loop round to 0, instead of looping at 256 as you would normally expect. This may be because of a bug in the picture drawing code in the interpreter. If you loop at 256 then some of the patterns will not be correct.

When a texture pattern is drawn in the shape of a circle, the texture pattern 'fills' the shape of the circle. This diagram will explain what I mean:

   X.XX          X.
   X.X.          XX
   ....         X.X.
   .X.X         ....
   X...         .X.X
   ..X.          X.
   XXXX          ..

 Rectangle     Circle
The corner pixels of the circle which aren't part of the circle are totally ignored. The circle isn't just a cut out of the equivalent rectangle. A bit hard to explain. Look at the code for showpic.exe for more info.
IMPLEMENTING ALL THIS
Writing code to interpret the picture data in order to draw the picture on the screen is easier said than done. It turns out that you have to have a line drawing algorithm which exactly matches the one that Sierra uses. A pixel out of place can mean that a fill overflows or doesn't work at all.

You will also have to write your own fill routine because not many of the standard fill routines can stop at a multicoloured boundary. You are also dealing with two screens both of which will probably be stored in memory somewhere rather than the screen.

The picture screen has a starting state of being completely white. The priority screen has starting state of being completely red. It is important that you set all pixels in each screen to the relevant background colour else you won't get the right result.

GENERAL GUIDELINES
The screen mode used by the AGI games is the 320x200x16 standard EGA mode. However, all graphics is designed to be shown on a 160x200x16 mode. This was apparently the resolution that the original PCjr interpreter used. They stuck with it when they started supporting EGA and thus have a situation where each AGI pixel has a width of two normal 320x200 pixels.

LINE DRAWING
This routine is relatively straight forward and I suggest that you look at it and try to understand it or you'll be having headaches trying to get you're routines acting like the Sierra ones. Basically it draws a line from (x1, y1) to (x2, y2) using a function called pset to draw a single pixel. The function "round" is what makes it act like the Sierra. Essentially when it comes down to a 50:50 decision about where to put a pixel, the direction in which the line is being drawn is taken into account. I've only noticed one pixel out of place in all the screens I've tried SHOWPIC on which makes me believe its probably not a fault in this algorithm, but somewhere else in the code.

int round(float aNumber, float dirn)
{
   if (dirn < 0)
      return ((aNumber - floor(aNumber) <= 0.501)? floor(aNumber) : ceil(aNumber));
   return ((aNumber - floor(aNumber) < 0.499)? floor(aNumber) : ceil(aNumber));
}

void drawline(word x1, word y1, word x2, word y2)
{
   int height, width;
   float x, y, addX, addY;

   height = (y2 - y1);
   width = (x2 - x1);
   addX = (height==0? height:(float)width/abs(height));
   addY = (width==0? width:(float)height/abs(width));

   if (abs(width) > abs(height)) {
      y = y1;
      addX = (width == 0? 0 : (width/abs(width)));
      for (x=x1; x!=x2; x+=addX) {
         pset(round(x, addX), round(y, addY));
         y+=addY;
      }
      pset(x2,y2);
   }
   else {
      x = x1;
      addY = (height == 0? 0 : (height/abs(height)));
      for (y=y1; y!=y2; y+=addY) {
         pset(round(x, addX), round(y, addY));
         x+=addX;
      }
      pset(x2,y2);
   }
}
The functions floor, ceil, and abs are all standard C functions, but for all you none C programmers, here's what they do:

floor: rounds a floating point number down.

ceil: rounds a floating point number up. abs: returns the absolute value of a number |x|.

FLOOD FILLING
I have discovered that using a queue in a flood fill routine works quite well. It is also the easiest method to understand as far as I'm concerned. I just thought about what needed to be done and this method took shape.

Basically you start at a particular location. If its the desired background colour (white or red depending on the screen), then set that pixel. You then check the pixels immediately up, left, down, and right to see if they are of the desired background colour. If they are, store them in the queue. You then retrieve the first pixel position from the queue and repeat the above steps.

USING HIGHER RESOLUTION MODES
I've often wondered if it would be possible to show PICTUREs in a higher resolution, for example, 640x400. Since the data is stored as vectors, it should be possible to multiply all the x components by four and all the y components by two and then draw the lines. This would give less blocky pictures. There would be a number of problems to overcome. Firstly, the fill action (or tool) may cause problems because pixels could be in the wrong places. There will also be a need to draw end pixels of a line with a width of four so that there are no holes for the flood fill to flow out of.

SIERRAS PICTURE EDITOR
The picture editor that Sierra used back in the vector picture days was much like a CAD program. I've seen a few photos of it in "The Official Book of King's Quest". It has a status bar at the top which gives the current tool being used (Line, Fill, etc), the current X and Y locations, and four others which I explain below.

Status bar examples:

Tool:Line V:8 P:A C:o X=249 Y=89 Pri:5
Tool:Fill V:B P:0 C:B X=96 Y=99 Pri:6
Tool:Line V:A P:o C:o X=199 Y=55 Pri:2 
o=off (or disabled)

Pri looks like it could be giving the current priority band that the cursor location is in. The above status lines are for the SCI Picture Editor. I ran these values past SQ3 and the values given for Pri are indeed the values of the priority band at the locations given.

I think that V, P, and C refer to the colours being used on the three different screens (the SCI games have a separate screen for the control lines rather than having both the priority bands and control lines on the same screen. This is why there were three screens and not the two that we are used to in AGI games). This would mean that V=Visual, P=Priority and C=Control.

In an AGI Picture Editor, there would only be the Visual screen and the Priority screen. The picture editor would obviously be able to switch between the two screens. I've also noticed that the early vector based SCI picture editor supports a feature which removes solid colours (Fills) with a single keystroke and I presume another keystroke puts them back. When the fills have been removed, they are represented as a tiny cross. Apparently removing the solid colours makes it easier to add small details like flowers.
 
5.2 PICTURE Resource Format
from AGDS docs*
Last updated: 27 January 1998
Retrived from the Internet Archive
 
* This is from the manual of AGDS (Adventure Game Development Toolkit) which contains a good deal of information about the AGI interpreter and its data formats. Translated from Russian by Vassili Bykov, vbykov@cam.org

 
(Translated from a russian document. The first part does not refer to the PICTURE resource format but gives a more detailed discussion of the picture commands used and the priority screen. The second part gives the format of a PICTURE resource).

I.2.1 THE PICTURE RESOURCE
This resource is used for static images (props), which create a background for animated objects programmatically associated with VIEW resources. (see I.2.2). The background is 160 pixels wide and 168 pixels high. Each pixel is painted using one of 16 colours. To create a 3D illusion, each pixel has another attribute: priority.

Priority determines the distance of each pixel from the viewer. Pixels which have the greater priority are considered to be closer and vice- versa. Priority is a value in the range between 0 and 15.

When an animated object (a VIEW resource) is displayed, it is drawn only on top of the pixels with the priority not greater than the object's. This creates an illusion of moving behind or in front of other objects.

Priority 4 is considered in the far back (objects cannot move behind it), priority 15 - the closest to the viewer (objects cannot move in front of it).

Priorities 0, 1, 2, 3 are special. Lines and areas of a PICTURE resource with priorities 0, 1, 2, 3 represent:

0 - unconditional barrier (border)
1 - conditional barrier
2 - alarm barrier
3 - water surface.

Picture resource is a sequence of commands produced by an editor of static images, Picture Manager (PM). Playing back the sequence draws an image used as the background of the action, and assigns required priorities to its pixels, thus creating a 3D scenery.

Please note that the drawing commands the picture-resource includes (described in section I.2.1) are created automatically by the Picture Manager (PM) as the artist draws the background he or she wants.

Let us look closer at these commands (see also the PM description).

I.2.1.1 SET COLOUR COMMAND
Initially all pixels of the background are white and have priority 4. We can draw using the following colours:

0 - black	8 - dark drey
1 - blue	9 - light blue
2 - grueen	10 - light green
3 - cyan	11 - light cyan
4 - red	12 - light red
5 - magenta	13 - light magenta
6 - brown	14 - yellow
7 - light grey	15 - white
To change colours, this command is used. After it is executed, all the subsequent graphic commands draw using the colour set by the command.

I.2.1.2 CANCEL COLOUR COMMAND
This command is used if we have already drawn the image. Any graphic command issued after this one will not change the colour of image pixels the draw.

I.2.1.3 SET PRIORITY COMMAND
All graphic command issued after this one will set priority of the pixels they draw to the one set by this command.

I.2.1.4 CANCEL PRIORITY COMMAND
Any graphic command issued after this one will not change priority of the pixels they draw.

I.2.1.5 POLYLINE COMMAND
Several graphic commands are used to draw images. There are several polyline drawing commands and a curved line command.

The first polyline command draws a line using the current colour and priority. The line consists of horizontal and vertical line fragments and begins with a vertical line.

Here is an example. First line fragment, always vertical:

                          (x,y)
                            |
                            |
                            V
                          (x,y1)
where x = horizontal coordinate, and y = vertical coordinate.

Since we draw a vertical line, X coordinate does not change. The next line fragment is horizontal, so now Y coordinate does not change:

                          (x,y)
                            |
                            |
                            V
                            *---------->(x2 ,y1)
                          (x,y1)
X is now x2, indicating that it is the second time it has changed.

In a similar fashion:

                     (x,y)     (x2,y3)
                     |          *----------->(x4,y3)
                     |          ^
                     V          |
                     *--------->*
                   (x,y1)      (x2,y1)
There is no need to specify the whole sequence of coordinates (x,y), (x,y1), (x2, y1), (x2, y3), (x4, y3). Instead, it is enough to list only the coordinates that change, since we know the order of their changes (first - Y, then X, then Y again and so on). Thus, to describe this line it is enough to list (x, y, y1, x2, y3, x4).

It is this sequence of numbers that is used as the command operands.

The second polyline command is similar to the first but the first line fragment is horizontal.

             (x,y) ------------>* (x1,y)
                                |
                                |               ...
                                |               |
                                V               |
                                *-------------->*
                              (x1,y2)        (x3,y2)
It is described by the sequence (x, y, x1, y2, x3, ...)

The third command draws an arbitrary polyline.

                       (x1,y1)
                         /\
                        /  \
                       /    \
                      /      \      ...  (x3,y3)
                     /        \    /
                  (x,y)        \  /
                                \/
                              (x2,y2)
It is described by the sequence (x, y, x1, y1, x2, y2, ...).

I.2.1.6 CURVE COMMAND
[I think "curve" is a actually a misnomer, this is just a polyline with each successive point specified relative to the previous one. --VB]

This is a variant of an arbitrary polyline command that draws a polyline made of very short line fragments.

The line goes from point (x,y) to the point (x1,y1), then to the point (x2,y2), etc.

The operands are x, y, dx1, dy1, dx2, dy2, ..., where dx(n) = x(n-1) - x(n), dy(n) = y(n-1) - y(n)

I.2.1.7 FLOOD FILL COMMAND
This command fills a closed area using the current colour and priority, beginning at a point inside the area. One command may fill one or more areas using pairs of coordinates within them.

The command works as follows:

1. If the current colour is set and is not 15 (i.e. not white), then the area to fill is the closed white area containing the argument point.

2. If the current colour is not set (was cancelled), the area to fill is the closed area of pixels with priority 4 containing the argument point.

Thus, it is impossible to repaint non-white areas or change priority if it is different from 4.

I.2.1.8 DOTS DRAWING COMMAND
This command has two parts. The first specifies the parameters of the dots, the second - the dots themselves.

Dot parameters

Parameters in this part are:

1) a number from 0 to 7 giving the size of the dot.

2) if the size above is greater than 2, this parameter chooses whether the dot is drawn as a square (1) or as a circle (0).

3) selects whether the dot is opaque or "translucent", so that 1/3 of the pixels within the dot are left unchanged.

Dots

This part lists the coordinates where to draw the dots: x1, y1, x2, y2, ... where x(i), y(i) is the coordinate of the center of the dot.

If the dots are "translucent", a third parameter r(i) is required for each dot, determining the distribution of painted pixels within the dot.

I.2.1.9 END COMMAND
This command ends the drawing, and is required at the end of a picture resource. See the description of PM editor for more information about graphics commands.

 

 

A.2.1 PICTURE RESOURCE FORMAT
Picture resource is a sequence of graphics commands, execution of which creates the background pictures and assigns required priorities to its pixels.

A command is a one-byte operation code, optionally followed by one-byte operands. Commands are stored one after another.

1. Set current colour
Code F0. Operand: colour code

Initially all pixels of the background are white and priority 4.

Example: F0 0C - set current colour to bright red

All command following this command will use this colour for drawing.

2. Cancel current colour
Code F1.

3. Set current priority
Code F2. operand: priority

Example: F2 0D - set current priority to 13

4. Cancel current colour
Code F3.

5. Display polyline
The commands display polylines

Code F4. Operands: x,y,y1,x2,y3,x4,...

Draws a polyline using current colour and priority. The line consists of horizontal and vertical fragments, the first fragment is vertical.

Example: F4 28 32 64 78 32 29

Draws a rectangle in the centre of the screen

                 (40,50)                      (120,50)
                        *--------------------*
                        |                    |
                        |                    |
                        *--------------------*
                 (40,100)                     (120,100)
Code F5. Operands: x, y, x1, y2, x3, y4,....

Similar to F4 but the first line fragment is horizontal.

Example: F5 28 32 78 64 28 33

Draws the same rectangle.

Code F6. Operands: x,y,x1,y1,x2,y2,x3,y3,.....

Draws a polyline of random line fragments.

Example: F6 50 32 28 64 78 64 50 32

        Triangle                    (80,50)
                                      /\
                                     /  \
                                    /    \
                           (40,100) ------ (120,100)
Code F7. Operands: x,y, dd1, dd2, dd3,....

This is a variant of a random polyline drawing command which draws a polyline made of very short line fragments.

dd1, dd2, etc. mean packed in one byte two values dx and dy - offsets from the previous polyline vertex.

Sx	x	x	x	Sy	y	y	y
x x x - value between 0 and 6 - value of dx if Sx = 1; between 0 and 7 - if Sx = 0; y y y - value between 0 and 7 - value of dy;

Sx, Sy - if this bit is 0, the value is positive, otherwise it is negative.

Example: F7 4D 4D 60 06 E0 0D

                  (77,77)            (83,77)
                        *------------*
                        |            |
                        |            |
                        |            |
                        *------------*
                  (77,83)             (83,83)
6. Draw a dot
Code F8. Operands x1, y1, x2, y2, x3, y3,.....

7. Draw a dot
Code F9. Operand: p.

Operand format:

 	r	 	c	 	s	s	s
s s s - a number between 0 and 7: the size of the dot

c - if the dot is larger than 2 and this bit is 1, the dot is drawn as a circle, otherwise - as a square.

r - if this bit is 1, the dot is "translucent", so that 1/3 of the pixels are not painted.

Other bits should be set to 0.

Code FA.

Operands: if in the previous F9 command bit r=0, then x1, y1, x2, y2, x3, y3,..... if r=1 r1, x1, y1, r2, x2, y2, r3, x3, y3,.....

x(i), y(i) - coordinates of the dot centre

r(i) - arbitrary value which determines the distribution of painted elements within a "translucent" dot.

8. End
Code FF.

6.1 VIEW Resource Format
by Peter Kelly
Last updated: 5 October 1997
Retrived from the Internet Archive
 
Overview
View resources contain some of the graphics for the game. Unlike the picture resources which are full-screen background images, view resources are smaller 'sprites' used in the game, such as animations and objects. They are also stored as bitmaps, whereas pictures are stored in vector format.

Each view resource consists of one or more 'loops'. Each loop in the resource consists of one or more 'cels' (frames). Thus several animations can be stored in one view, or a view can just be used for a single image. The maximum number of loops supported by the interpreter is 255 (0-254) and the maximum number of cels in each is 255 (0-254).

View header (7+ bytes)
Note: ls,ms means that the value is a two-byte word, with the least significant byte stored first, and the most significant byte stored second, e.g. 12 07 is acually 712 (hex) or 1810 (decimal). Most word values in AGI are stored like this, but not all.

Byte	Meaning
0	Unknown (always seems to be either 1 or 2)
1	Unknown (always seems to be 1)
2	Number of loops
3-4	Position of description (more on this later) (ls,ms)
Both bytes are 0 if there is no description.
5-6	Position of first loop (ls,ms)
7-8	Position of second loop (if any) (ls,ms)
9-10	Position of third loop (if any) (ls,ms)
....	 
Note: Two of these loop references CAN point to the same place. This is done when you want to use mirroring (more on this later).

Loop header (3+ bytes)
Byte	Meaning
0	Number of cels in this loop
1-2	Position of first cel, relative to start of loop (ls,ms)
3-4	Position of second cel (if any), relative to start of loop (ls,ms)
5-6	Position of third cel (if any), relative to start of loop (ls,ms)
Cel header (3 bytes)
Byte	Meaning
0	Width of cel (remember that AGI pixels are 2 normal EGA pixels wide so a cel of width 12 is actually 24 pixels wide on screen)
1	Height of cel
2	Transparency and cel mirroring
The first four bits of this byte tell the interpreter how to handle the mirroring of this cel (explained later).

The last four bits represent the transparent color. When the cel is drawn on the screen, any pixels of this color will show through to the background.

All cels have a transparent color, so if you want an opaque cel then you must set the transparent color to one that is not used in the cel.

Cel data
The actual image data for each cel is stored using RLE (run length encoding) compression. This means that instead of having one byte for each single pixel (or 1/2 byte as you would use for 16 colors), each byte specifies how many pixels there are to be in a row and what colour they are. I will refer to these groups of pixels as 'chunks'.

This method of compression is not very efficient if there is a lot of single pixels in the image (e.g. a view showing static on a TV screen), but in most cases it does save a fair amount of space.

Each line (not to be confused with a chunk) in the cel consists of several bytes of pixel data, then a 0 to end the line. Each byte of pixel data represents one chunk. The first four bits determine the colour, and the last four bits determine the number of pixels in the chunk.

e.g. AX BY CZ 00

This line will have:	X pixels of colour A	[AX]
 	Y pixels of colour B	[BY]
 	Z pixels of colour C	[CZ]
(then that will be the end of the line)	[00]
If the color of the last chunk on the line is the transparent color, there is no need to store this. For example, if C was the transparent color in the above example, you could just write AX BY 00. This also saves some space.

Mirroring
Mirroring is when you have one loop where all the cels are a mirror image of the corresponding cels in another loop. Although you could do this manually by drawing one loop and then copying and pasting all the cels to another loop and flipping them horizontally, AGI views provide the ability to have this done automatically - you can draw one loop, and have another loop which is set as a mirror of this loop. Thus, when you change one loop you change the other. This is useful if you have an animation of a character walking left and right - you just draw the right-walking animation and have another loop a mirror of this which will have the left-walking animation. Another advantage of cel mirroring is to save space - it doesn't make much difference these days, but back when AGI was written the games were designed to run on 256k systems which meant that memory had to be used as efficiently as possible.

Mirroring is done by having both loops share the same cel data - you saw above that you can have two loop references pointing to the same place. The first four bits of the 3rd byte in the header of each cel tell the interpreter what is mirrored:

Bit 1 specifies whether or not this cel is mirrored.
Bits 1,2 and 3 specify the number of the loop (from 0-7) which is NOT mirrored.

When the interpreter goes to display a loop, it looks at the bit 1 and sees if it is mirrored or not. If it is, then it checks the loop number - if this is NOT the same as the current loop, then it flips the cel before displaying it.

Leaving enough room for the mirrored image:
If you have a cel that is mirrored, you need to ensure that the number of bytes the cel takes up in the resource is greater than or equal to the number of bytes that the flipped version of the cel would take up.

The reason for this is that the interpreter loads the view resource into memory and works with that for displaying cels, rather than decoding it and storing it in memory as a non-compressed bitmap. I assume that it doesn't even bother 'decoding' it as such - it probably just draws the chunks of color on the screen as they are. When it has to display the flipped version of a cel, instead of storing the flipped cel somewhere else in memory, it flips the version that is there. So in memory you have the view resource that was read from the file, except that some of the cels have been changed. This is why there is mirroring information stored in each cel - the interpreter has to know what cels have been changed. When it flips a cel, it changes the loop number in the 3rd byte of the cel header to the number of the loop it is currently displaying the cel for. So when it looks at this number the next time for a different loop, it will see that the cel is not the right way round for that loop and mirror it again.

This process seems very inefficient to me. I don't know why it doesn't just draw the chunks of color on the screen back to front. But since it does it this way we have to make sure that there is enough room for the flipped cel.

It seems that not all versions of the interpreter require this, however - I was working with version 2.917 when I was testing this out, but I noticed that versoin 2.440 did not require this. I will attempt to try this with all different interpreters and provide a list of which ones use this in the next version of this document. But it is best to put these bytes in just in case, as the views will still work regardless.

Description
All the Views in the game that are used as close-ups of inventory items have a description. When a player 'examines' these (in some games you can select 'see object' from the menu), they will see the first cel of the first loop of this view and the description of the object they are examining. This is brought up using the show.obj command.

The Description is stored in plain text, and terminated by a null character. Lines are separated by an 0x0A.


6.2 VIEW Table & VIEW Test Commands
by Lance Ewing
Last updated: 31 August 1997
Retrived from the Internet Archive
 
Firstly we should note that there is a difference between a VIEW and a VIEW object. A VIEW is a collection of animated sequences that are stored in a VOL file. When a view is loaded into memory, it is then connected to one or more VIEW table entries (see below) that store information on what the interpreter calls objects (don't confuse this with inventory items). An object is an animated sprite that is currently being controlled by the interpreter. With each interpretation cycle, the state of each object in the VIEW table is updated and, if required, updated on the screen. It is therefore possible to have five or more hungry crocodiles swimming in a moat each which have there own VIEW table entries, all of which point to the same VIEW data.

View objects appear to have the following properties:

x position:
y position:
current view:
current loop:
current cel:
priority:
cycle time: 1/n gives the fraction of the maximum speed.
step time: 1/n gives the fraction of the maximum speed.
x size: in pixels
y size: in pixels
step size:
direction:
number of loops:
number of cels:

There are probably other properties that aren't listed here which they also possess. In an object oriented environment such as SCI, these properties are stored as instance variables (or selectors) as part of the object. Since AGI isn't object oriented, we would expect to find some sort of VIEW table stored in memory which holds theses properties within it. In SQ2 this VIEW table consisted of 43 byte entries. Most commands that deal with VIEW objects will make adjustments to the data in the entry for the relevant object.

VIEW TABLE ENTRY
Offset	Function
00-01	step.time (stored twice)
02	??
03-04	x position
05-06	y position
07	current view
08-09	pointer to start of view data.
0A	current loop
0B	number of loops
0C-0D	pointer to start of loop data
0E	current cel
0F	number of cels
10-11	pointer to start of cel data
12-13	pointer to start of cel data (same as above)
14-15	??
16-17	copy of x position
18-19	copy of y position
1A-1B	x size
1C-1D	y size
1E	step size
1F-20	cycle time (stored twice)
21	direction (heading)
0 = stationary
1 = north
2 = north/east
3 = east
4 = south/east
5 = south
6 = south/west
7 = west
8 = north/west
22	0 = normal.motion
1 = wander
2 = follow.ego
3 = move.obj
23	0 = normal.cycle
1 = end.of.loop
2 = reverse.loop
3 = reverse.cycle
24	priority
25-26	View Flags
Bit	Function
0	??
1	0= observe blocks, 1 = ignore blocks
2	0 = priority released, 1 = fixed priority
3	0 = observe horizon, 1 = ignore horizon
4	??
5	0 = stop cycling, 1 = cycling.
6	??
7	??
8	1 = view on water
9	0 = observe objects, 1 = ignore objects
10	??
11	1 = view on land
12	??
13	0 = loop released, 1 = loop fixed
14	??
15	??
27	?? Storage for some view related command parameters.
28	?? Storage for some view related command parameters.
29	?? Storage for some view related command parameters.
2A	?? Storage for some view related command parameters.
Note: The above format structure is simply the way in which Sierras AGI interpreter stores information about VIEW objects. In attempting to write an AGI interpreter, you would not have to restrict yourself to this format, just as long as you store this information in some manner that the interpreter can have access to.

TEST COMMANDS AND VIEWS
There are four test commands that are to do with VIEWS. These are:

obj.in.box
posn
right.posn
centre.posn 
All of these commands are for testing whether a VIEW object is within a given rectangle on the screen. All of them take the same parameters and apart from a slight change in each case, they do exactly the same thing and even share about 95% of their code. The general form is the following:

command(VIEW object num, left, top, right, bottom)

A VIEW has a position stored in its VIEW table entry that says where abouts on the screen the view object is at the present time. The problem with this position is saying which pixel is the position pixel for an object that takes up usually over a hundred pixels. Okay, you might say that most views are actors or props that sit on the ground and therefore the bottom row of pixels will give you a y position. This is a good argument, but now you need to say which of these pixels in the bottom row is the actual position. Sierra must have faced this problem or they wouldn't have provided four commands for achieving essentially the same thing.

By default the position hot spot in a VIEW is the bottom left pixel.

   .........
   .........
   .........
   .........          X = position hot spot.
   .........
   .........
   X........
This is the location that gets stored in the VIEW object table. The difference between the test commands given above is how they adjust the x position before testing it against the rectangle border lines.

posn Leaves the x position as it is (left side). right.posn Adds the x size - 1 to the x position giving the right side. center.posn Adds (xsize/2) to the x position giving the centre. obj.in.box Tests both the left and right sides which essentially tests whether the whole bottom row of pixels is in the 'box'.

posn	Leaves the x position as it is (left side).
right.posn	Adds the x size - 1 to the x position giving the right side.
center.posn	Adds (xsize/2) to the x position giving the centre.
obj.in.box	Tests both the left and right sides which essentially tests whether the whole bottom row of pixels is in the 'box'.
 

Command	X1	X2	Y
posn	x	x	y
right.posn	x + xsize - 1	x + xsize - 1	y
center.posn	x + (xsize/2)	x + (xsize/2)	y
obj.in.box	x	x + xsize - 1	y
Test is TRUE if:

(X1 >= left) && (y >= top) && (X2 <= right) && (y <= bottom)

7.1 SOUND Resource Format
by Lance Ewing
Last updated: 18 August 1997
Retrived from the Internet Archive
 
NOTE: The original version of this document did not cover every aspect of the sound format. It made no mention that the volume control and noise voice were also part of AGI's sound format. It turns out that the data contained in a sound resource is so much like the data sent to the PCjr's T1 chip that I have included a lot of Peter Nortons T1 sound chip section from the "Programmers Guide to the IBM PC".

INTRODUCTION
Most people who think of AGI games remember that they played their music and sounds over the PC speaker. What they may not know is that all sounds are composed of four parts, one which is the melody, two which are accompaniment, and the final one being noise. The IBM PC can only play one note at a time so all AGI games for the PC play the melody by itself. The other three parts are still included in the data though because some PC comptibles, including the IBM PCjr, have more than one sound generator.

HISTORY
According to Donald B. Trivette author of 'The Official Book of King's Quest', a year before the IBM PCjr was announced IBM asked Sierra to create a game that would show off the new computers color graphics capabilities. IBM supplied the company with a prototype Junior, and Roberta set to work designing a new type of adventure game. The game produced was called King's Quest. This is important because the IBM PCjr had a different method of sound generation than the IBM compatibles of today. The sound data was stored to make it easy to send to the Juniors sound generators. This format appears to have remained right through the AGI games up until 1989-90 when SCI took over even though the PCjr had long since been surpassed by the 286, and 386.

SOUND AND THE IBM PCjr
The best known source of sound in the Junior is the TI SN76496A sound generator chip. This source has four separate sound voices. Three of these are tone generators and the fourth is a noise source. All four voices have an independent volume control, providing an evenly graduated set of 15 volume levels, plus a zero volume (off). Each of the three pure voices has an independently selected frequency. The noise voice has three preselected frequencies and a fourth option, which borrows the frequency of the third pure voice. The data stored in the AGI games is designed to be sent to these four voices.

THE TONE GENERATIONS
A tone is produced on a voice by passing the sound chip a 3-bit register address and then a 10-bit frequency divisor. The register address specifies which voice the tone will be produced on. This is done through port 192 on the IBM PCjr by sending it 2 bytes in the following format:

First Byte

 7  6  5  4  3  2  1  0

 1  .  .  .  .  .  .  .      Identifies first byte (command byte)
 .  R0 R1 R2 .  .  .  .      Register number in T1 chip (0, 2, 4).
 .  .  .  .  F6 F7 F8 F9     4 of 10-bits in frequency count.
Second Byte

 7  6  5  4  3  2  1  0

 0  .  .  .  .  .  .  .      Identifies second byte (completing byte)
 .  X  .  .  .  .  .  .      Unused, ignored.
 .  .  F0 F1 F2 F3 F4 F5     6 of 10-bits in frequency count.
Register Addresses:

R0	R1	R2

0	0	0		Holds voice 1 frequency number.
0	1	0		Holds voice 2 frequency number.
1	0	0		Holds voice 3 frequency number.
The actual frequency produced is the 10-bit frequency divisor given by F0 to F9 divided into 1/32 of the system clock frequency (3.579 MHz) which turns out to be 111,860 Hz. Keeping all this in mind, the following is the formula for calculating the frequency:

F = 111860 / (((Byte-2 AND 0x3F) * 16) + (Byte-1 MOD 16));

Note: The order of the bytes are reversed for AGI sound data.

ATTENUATION
Each voice in the T1 sound chip has an independent sound-level control, which is calculated in terms of decibels of attenuation, or softening. There are four bits uses to control the volume. These bits, labeled A0 through A3, can be set independently or added together to produce sixteen volume levels as shown below.

 A0 A1 A2 A3        Value        Attenuation (decibels)

  .  .  .  1          1                    2
  .  .  1  .          2                    4
  .  1  .  .          4                    8
  1  .  .  .          8                   16
  1  1  1  1                           Volume off
When a bit is set on, the sound is attenuated (reduced) by a specific amount: either 2, 4, 8, or 16 decibels. When all four bits are set on, the sound is turned completely off. When all four bits are off, the sound is at
its fullest volume.

The attenuation is set by sending a byte of the following format to the T1 sound chip:

 7  6  5  4  3  2  1  0

 1  .  .  .  .  .  .  .      Identifies first byte (command byte)
 .  R0 R1 R2 .  .  .  .      Register number in T1 chip (1, 3, 5, or 7).
 .  .  .  .  A0 A1 A2 A3     4 attenuation bits
Register Addresses:

		R0	R1	R2

      0  0  1     Holds voice 1 attenuation.
      0  1  1     Holds voice 2 attenuation.
      1  0  1     Holds voice 3 attenuation.
      1  1  1     Holds noise voice attenuation.
THE NOISE GENERATOR

There are two modes for the noise operation, besides the four frequency selections. One, called periodic noise, produces a steady sound; the other, called white noise, produces a hissing sound. These two modes are controlled by a bit known as the FB bit. When FB is 0, the periodic noise is generated; when FB is 1, the white noise is produced.

Two bits, known as NF0 and NF1, control the frequency at which the noise generator works. Three of the four possible combinations of NF0 and NF1 set an independent noise frequency based on the timer. The fourth combination borrows the frequency from the third of the three pure voices made by the tone generators.

 NF0  NF1       Noise Frequency

  0    0         1,193,180 / 512 = 2330
  0    1         1,193,180 / 1024 = 1165
  1    0         1,193,180 / 2048 = 583
The noise frequency is set by sending a byte of the following format to the T1 sound chip:

 7  6  5  4  3  2  1  0

 1  .  .  .  .  .  .  .      Identifies first byte (command byte)
 .  1  1  0  .  .  .  .      Register number in T1 chip (6)
 .  .  .  .  X  .  .  .      Unused, ignored; can be set to 0 or 1
 .  .  .  .  .  FB .  .      1 for white noise, 0 for periodic
 .  .  .  .  .  . NF0 NF1    2 noise frequency control bits
AGI SOUND FILES

We now know enough about the PCjr's T1 sound chip to discuss the AGI sound format. The sound is stored as four separate units of data, one for each voice. Each sound file stored in the VOL files has an 8-bit header which contains offsets into file. The format is as follows:

Byte	Meaning
0-1	Offset of first voice data.
2-3	Offset of second voice data.
4-5	Offset of third voice data.
6-7	Offset of noise voice data.
The data starting at each voice offset is stored as 5-byte notes which give the frequency and duration of a note played on that voice. The 5 bytes have the following meanings:

Byte

0-1 Duration (16-bit word)
2-3 Frequency divisor of the format described in the PCjr section
above except the two bytes are around the other way.
4 Attenuation of the note in the format described above in the PCjr
section.

Byte	Meaning
0-1	Duration (16-bit word)
2-3	Frequency divisor of the format described in the PCjr section above except the two bytes are around the other way.
4	Attenuation of the note in the format described above in the PCjr section.
Note that the last three bytes were around the other way in version 1 of the AGI interpreter. The above order is opposite from the order that would be output to the T1 sound chip.

Each voice's data section in the SOUND resource file is usually terminated by two consecutive 0xFF codes. Another way of checking for the end is to see if it has reached the start of the next voice section, or in the case of the noise voise, the end of the SOUND data.

PLAYING THE SOUNDS ON A SOUND CARD
Writing a program to play the tunes will require four pointers which keep track of where in each voice segment the program currently is since all four voices are played simultaneously. The first voice is the melody and is the voice that is played on the PC speaker in today's modern PC compatibles, the other two voices being ignored. I'd imagine that other platforms such as the Amiga and Macintosh would probably play all three voices.

A program would start by reading each of the four offsets in the header. It would then go through a loop which begins by reading the first note of each voice section. The duration's are then monitored and when each note finishes, another note is read. Note that the notes for each voice will usually finish at different times. The program finishes when all of the voice sections have been entirely played. This will usually occur for each voice at the same time but not necessarily I don't think.

Then of course you could always convert the AGI SOUND to a MIDI file and play that which will sound a hundred times better :)

CALCULATING FREQUENCIES WHEN PLAYING NOTES ON A SOUND CARD
My program reads in the duration as a 16 bit word. It then loads the two following bytes and calculates the frequency as follows:

Freq. = 111860 / (((Byte-2 AND 0x3F) * 16) + (Byte-3 MOD 16));

The 111860 comes from the PCjr discussion above. Note that the bytes are in the opposite order from that mentioned in the PCjr information.

Remember also that the SOUND format includes volume information for each voice. The exact conversion from the decible values to the volume control on todays sound cards is uncertain at this stage.

APPENDIX 1: SOUND FORMAT SUMMARY
The header consists of four two-byte offsets, one for each voice. The low byte is first, followed by the high byte. Each offset points to the note data for the relevant voice. The note data for a voice consists entirely of five-byte note entries of the following format:

FIRDT BYTE
SECOND BYTE

Note duration (low byte and then high byte).

THIRD BYTE

  ---> In the case of a tone voice,

   7  6  5  4  3  2  1  0

   0  .  .  .  .  .  .  .      Always 0.
   .  X  .  .  .  .  .  .      Unused, ignored.
   .  .  F0 F1 F2 F3 F4 F5     6 of 10-bits in frequency count.


  --->  In the case of the noise voice, this byte is equal to zero.
FOURTH BYTE

  ---> In the case of a tone voice,

   7  6  5  4  3  2  1  0

   1  .  .  .  .  .  .  .      Always 1.
   .  R0 R1 R2 .  .  .  .      Register number in T1 chip (0, 2, 4).
   .  .  .  .  F6 F7 F8 F9     4 of 10-bits in frequency count.

   F = frequency = 111860 / (((Byte-3 AND 0x3F) * 16) + (Byte-4 MOD 16))
   R = register address


   ---> In the case of the noise voice,

   7  6  5  4  3  2  1  0

   1  .  .  .  .  .  .  .      Always 1.
   .  1  1  0  .  .  .  .      Register number in T1 chip (6)
   .  .  .  .  X  .  .  .      Unused, ignored; can be set to 0 or 1
   .  .  .  .  .  FB .  .      1 for white noise, 0 for periodic
   .  .  .  .  .  . NF0 NF1    2 noise frequency control bits

   NF0  NF1       Noise Frequency

    0    0         1,193,180 / 512 = 2330
    0    1         1,193,180 / 1024 = 1165
    1    0         1,193,180 / 2048 = 583
FIFTH BYTE

   7  6  5  4  3  2  1  0

   1  .  .  .  .  .  .  .      Identifies first byte (command byte)
   .  R0 R1 R2 .  .  .  .      Register number in T1 chip (1, 3, 5, or 7).
   .  .  .  .  A0 A1 A2 A3     4 attenuation bits


   A0 A1 A2 A3        Value        Attenuation (decibels)

    .  .  .  1          1                    2
    .  .  1  .          2                    4
    .  1  .  .          4                    8
    1  .  .  .          8                   16
    1  1  1  1                           Volume off


 Register Addresses:

   R0 R1 R2        Parameter

    0  0  0        Voice 1 frequency control number (10 bits)
    0  0  1        Voice 1 attenuation (4 bits)
    0  1  0        Voice 2 frequency control number (10 bits)
    0  1  1        Voice 2 attenuation (4 bits)
    1  0  0        Voice 3 frequency control number (10 bits)
    1  0  1        Voice 3 attenuation (4 bits)
    1  1  0        Noise voice control (4 bits; 3 used)
    1  1  1        Noise voice attenuation (4 bits)
The note data for one voice is terminated by two consecutive 0xFF values.

 

APPENDIX 2: AGI v1.12 SOUND FORMAT
The sound format used in version 1.12 of the AGI interpreter was quite different from the format described above for AGIv2 and AGIv3. It still uses the PCjr format for the note data but it does not store the duration as a separate field. The best way to describe it is by an example:

90 80 16 B0 A0 15 D0 C0 0E FF E4 00 80 17 A0 16 C0 11 00 80 16 B1 A0 14 C0 12 00 80 16 B2 A0 16 C0 13 00 ...

The first thing to point out is that the PCjr note data is in the opposite order to AGIv2. Secondly, all four parts are included together rather than in separate sections. Taking the above example, lets look at the first note and show the equivalent AGIv2 notation.

90 80 16 --> 03 00 16 80 90

Now, the duration isn't immediately obvious, but we will come to that in a short while. The followint three bytes give the first note for the second part, the third part, and the noise part (at least as far as this example is concerned).

B0 A0 15 --> 03 00 15 A0 B0
D0 C0 0E --> 03 00 0E C0 D0
FF E4 00 --> 33 00 00 E4 FF

The data that follows after these initial four starting notes is basically any changes in the note value which each 3 duration step. For example,

80 17 --> 03 00 17 80 90

Note that 0x90 doesn't need to be stored because that byte has retained its value. Every 0x00 byte that is encountered is the end of one set of note changes. Each set of note changes is the equivalent of a duration of 3 in the AGIv2 format. Continuing with our example,

A0 16 --> 03 00 16 A0 B0
C0 11 --> 03 00 11 C0 D0

The example now encounters a 0x00 byte which means that the noise voice isn't changed at this point. In fact, from the AGIv2 equivalent note above, you will see that the noise note will not change until 49 (or 0x33) sets of note changes have been processed.

80 16 --> 03 00 16 80 90
B1 A0 14 --> 03 00 14 A0 B1
C0 12 --> 03 00 12 C0 D0

How exactly the AGIv1.12 interpreter knows which voice is having its notes changed, and which bytes of the note are being changed, is not yet certain. On some occassion a sets of changes will contain only one byte which corresponds to one of the bytes which makes up one of the voices note value, but how it knows which one is a mystery to me.

On other occassions, there could be a whole chain of 0x00 bytes which means that during that whole time, none of the voices are changing their notes value.


8.1 OBJECT File Format
by Lance Ewing
Last updated: 31 August 1997
Retrived from the Internet Archive
 
The OBJECT file stores two bits of information about the inventory items used in an AGI game. The starting room location and the name of the inventory item. It also has a byte that determines the maximum number of animated objects.

The file encryption
The first obstacle to overcome is the fact that most OBJECT files are encrypted. I say most because some of the earlier AGI games were not, in which case you can skip to the next section. Those that are encrypted are done so with the string "Avis Durgan". The process of unencrypting the file is to simply taken every eleven bytes from the file and XOR each element of those eleven bytes with the corresponding element in the string "Avis Durgan". This sort of encryption is very easy to crack if you know what you are doing and is simply meant to act as a shield so as not to encourage cheating. In some games, however, the object names are clearly visible in the saved game files even when the OBJECT file is encrypted, so it's not a very effective shield.

The first three bytes
Byte	Purpose
0-1	Offset of the start of inventory item names.
2	Maximum number of animated objects.
Following the first three bytes as a section containing a three byte entry for each inventory item all of which conform to the following format:

Byte	Purpose
0-1	Offset of inventory item name i.
2	Starting room number for inventory item i or 255 carried.
where i is the entry number starting at 0. All offsets are taken from the start of entry for inventory item 0 (not the start of the file).

The inventory name section
Then comes the textual names themselves. This is simply a list of NULL terminated strings. The offsets mentioned in the above section point to the first character in the string and the last character is the one before the 0x00.

8.2 WORDS.TOK Format
by Lance Ewing
Last updated: 31 August 1997
Retrived from the Internet Archive
 
The WORDS.TOK file is used to store the games vocabulary, i.e. the dictionary of words that the interpreter understands. These words are stored along with a word number which is used by the 'said' test commands as argument values for that command. Many words can have the same word number which basically means that these words are synonyms for each other as far as the game is concerned.

The file itself is both packed and encrypted. Words are stored in alphabetic order which is required for the compression method to work.

THE FIRST SECTION
At the start of the file is a section that is always 26x2 bytes long. This section contains a two byte entry for every letter of the alphabet. It is essentially an index which gives the starting location of the words beginning with the corresponding letter.

Byte	Purpose
0-1	Hi and then Lo byte for 'A' offset.
.....	 
50-51	Hi and then Lo byte for 'Z' offset.
52-	Words section.
The important thing to note from the above is that the normal Lo-Hi byte order convention used everywhere else in the AGI system is not used here. For example, 0x00 and 0x24 means 0x0024, not 0x2400. This method is used later on for word numbers as well.

All offsets are taken from the beginning of the file. If no words start with a particular letter, then the offset in that field will be 0x0000.

THE WORDS SECTION
Words are stored in a compressed way in which each word will use part of the previous word as a starting point for itself. For example, "forearm" and "forest" both have the prefix "fore". If "forest" comes immediately after "forearm", then the data for "forest" will specify that it will start with the first four characters of the previous word. Whether this method is used for further confusion for would be cheaters or whether it is to help in the searching process, I don't yet know, but it most certainly isn't purely for compression since the WORDS.TOK file is usally quite small and no attempt is made to compress any of the larger files (before AGI version 3 that is).

Prefix	Char.1	Char.2	......	Last Char	WordNum Hi	WordNum Lo
Prefix - Number of characters to include from start of prevous word.
Char.n - 0x7F xor Char.n gives the ASCII code for the character.
Last Char - 0x7F xor (Char.n & 0x7F) gives ASCII code. Top bit is set to indicate end of word.
WordNum Hi - Hi byte of word number.
WordNum Lo - Lo byte of word number.

If a word does not use any part of the previous word, then the prefix field is equal to zero. This will always be the case for the first word starting with a new letter. There is nothing to indicate where the words starting with one letter finish and the next set starts, infact the words section is just one continuous chain of words conforming to the above format. The index section mentioned earlier is not needed to read the words in which suggests that the whole WORDS.TOK format is organised to find words quickly.

A NOTE ABOUT WORD NUMBERS
Some word numbers have special meaning. They are listed below:

Word #	Meaning
0	Words are ignored (e.g. the, at).
1	Anyword.
e.g.

  if (said(take, anyword))
    print("You can't - Blackbeard has chopped both
      your arms off.");
  }
9999	ROL (Rest Of Line). It does matter what the rest of the input list is. 